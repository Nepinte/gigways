<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Vinyl Designer</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">

  <style>
    :root{
      --first-color:#FFFAFA;
      --second-color:#121212;

      --third-color:#8F7A5B;
      --accent-color:#BFA889;
      --text-color-light:#7E7A74;
      --border-color:rgba(0,0,0,.1);

      --glass:rgba(255,255,255,.65);
      --glass-bd:rgba(0,0,0,.12);

      --shadow-sm:0 4px 16px rgba(0,0,0,.08);
      --shadow-md:0 10px 30px rgba(0,0,0,.12);

      --button-grad:linear-gradient(135deg,var(--third-color),var(--accent-color));
      --button-text:#fff;

      --body-font:'Poppins',sans-serif;
      --normal-font-size:.98rem;
      --small-font-size:.86rem;

      --ring:rgba(191,168,137,.28);
    }

    *{box-sizing:border-box;margin:0;padding:0}
    html{scroll-behavior:smooth; scrollbar-gutter: stable;}
    body{
      font-family:var(--body-font);
      font-size:var(--normal-font-size);
      color:var(--second-color);
      background:var(--first-color);
      min-height:100vh;
      padding:18px;
      line-height:1.6;
    }

    body::before{
      content:"";
      position:fixed;
      inset:-140px -140px auto -140px;
      height:520px;
      background:
        radial-gradient(closest-side at 20% 30%, rgba(191,168,137,.22), transparent 70%),
        radial-gradient(closest-side at 70% 20%, rgba(191,168,137,.16), transparent 68%),
        radial-gradient(closest-side at 40% 75%, rgba(0,0,0,.06), transparent 70%);
      filter: blur(2px);
      opacity:.9;
      pointer-events:none;
      z-index:-1;
    }

    .container{max-width:1400px;margin:0 auto}

    .header{
      background:var(--glass);
      border:1px solid var(--glass-bd);
      border-radius:22px;
      padding:18px 22px;
      box-shadow:var(--shadow-md);
      backdrop-filter: blur(12px) saturate(140%);
      -webkit-backdrop-filter: blur(12px) saturate(140%);
      margin-bottom:16px;
      position:relative;
      overflow:hidden;
    }
    .header::before{
      content:"";
      position:absolute;
      inset:-2px;
      background:
        radial-gradient(circle at 20% 10%,rgba(191,168,137,.22),transparent 55%),
        radial-gradient(circle at 80% 20%,rgba(143,122,91,.18),transparent 60%),
        radial-gradient(circle at 40% 90%,rgba(191,168,137,.16),transparent 60%);
      pointer-events:none;
      z-index:0;
    }
    .header > *{ position:relative; z-index:1; }

    .header h1{
      font-size:1.55rem;
      font-weight:900;
      letter-spacing:-.02em;
      margin-bottom:6px;
      color:var(--second-color);
    }
    .header h1 span{ color:var(--third-color); }
    .header p{
      color:var(--text-color-light);
      font-size:var(--small-font-size);
      line-height:1.55;
    }

    .workspace{
      display:grid;
      grid-template-columns:340px 1fr;
      gap:16px;
      min-height:600px;
      align-items:stretch;
    }

    .sidebar{
      background:var(--glass);
      border:1px solid var(--glass-bd);
      border-radius:22px;
      padding:16px;
      box-shadow:var(--shadow-md);
      backdrop-filter: blur(12px) saturate(140%);
      -webkit-backdrop-filter: blur(12px) saturate(140%);
      position: sticky;
      top: 18px;
      height: calc(100vh - 36px);
      overflow: hidden;
    }

    .canvas-area{
      background:var(--glass);
      border:1px solid var(--glass-bd);
      border-radius:22px;
      padding:18px;
      box-shadow:var(--shadow-md);
      backdrop-filter: blur(12px) saturate(140%);
      -webkit-backdrop-filter: blur(12px) saturate(140%);
      display:flex;
      flex-direction:column;
      position:relative;
      overflow:hidden;
    }

    .tab-buttons{display:flex;gap:10px;margin-bottom:14px}
    .tab-btn{
      flex:1;
      padding:12px;
      border:1px solid var(--border-color);
      border-radius:14px;
      background:rgba(255,255,255,.55);
      color:var(--second-color);
      font-weight:900;
      cursor:pointer;
      transition:.15s ease;
      font-size:13px;
      -webkit-tap-highlight-color:transparent;
    }
    .tab-btn.active{
      background:var(--button-grad);
      border-color:transparent;
      color:#fff;
      box-shadow:0 14px 34px rgba(0,0,0,.18);
    }

    .tab-content{
      display:none;
      height: calc(100% - 52px);
      overflow:auto;
      padding-right:6px;
      overscroll-behavior:contain;
    }
    .tab-content.active{display:block;animation:fadeIn .18s ease}
    @keyframes fadeIn{from{opacity:0;transform:translateY(6px)}to{opacity:1;transform:translateY(0)}}

    .section{margin-bottom:14px}
    .section-title{
      font-size:12px;
      font-weight:900;
      text-transform:uppercase;
      color:var(--text-color-light);
      margin:10px 0 10px;
      letter-spacing:.5px;
    }

    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .field{
      display:flex;
      flex-direction:column;
      gap:6px;
      padding:10px;
      border:1px solid var(--border-color);
      border-radius:14px;
      background:rgba(255,255,255,.55);
    }
    .field label{font-size:12px;color:var(--text-color-light);font-weight:900}
    .field input[type="number"]{
      width:100%;
      border:none;
      outline:none;
      font-size:14px;
      font-weight:900;
      background:transparent;
      color:var(--second-color);
    }

    .apply-row{
      display:grid;
      grid-template-columns:1fr auto;
      gap:10px;
      align-items:center;
      margin-top:10px;
    }
    .preset{
      padding:12px 12px;
      border:1px solid var(--border-color);
      border-radius:14px;
      background:rgba(255,255,255,.55);
      font-weight:900;
      font-size:13px;
      color:var(--second-color);
      cursor:pointer;
      outline:none;
    }

    .mini{font-size:12px;color:var(--text-color-light);line-height:1.35;margin-top:8px}

    .upload-zone{
      border:1px dashed color-mix(in srgb, var(--border-color) 70%, transparent 30%);
      border-radius:16px;
      padding:20px 14px;
      text-align:center;
      cursor:pointer;
      transition:.15s ease;
      background:rgba(255,255,255,.45);
    }
    .upload-zone:hover{border-color:rgba(191,168,137,.7);background:rgba(191,168,137,.08)}
    .upload-zone.dragover{border-color:rgba(191,168,137,.8);background:rgba(191,168,137,.14);transform:scale(1.01)}
    input[type="file"]{display:none}

    .control-group{margin-bottom:14px}
    .control-label{
      display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;
      font-size:13px;font-weight:900;color:var(--second-color);
    }
    .control-value{color:var(--third-color);font-weight:900}

    input[type="range"]{
      width:100%;
      height:6px;
      border-radius:999px;
      background:rgba(0,0,0,.12);
      outline:none;
      -webkit-appearance:none;
      cursor:pointer;
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none;
      width:18px;height:18px;border-radius:50%;
      background:var(--button-grad);
      box-shadow:0 10px 22px rgba(0,0,0,.20);
      border:1px solid rgba(0,0,0,.06);
    }

    textarea{
      width:100%;
      padding:12px;
      border:1px solid var(--border-color);
      border-radius:14px;
      font-size:14px;
      font-family:inherit;
      resize:vertical;
      min-height:90px;
      outline:none;
      transition:.15s ease;
      background:rgba(255,255,255,.55);
      color:var(--second-color);
    }
    textarea:focus{
      border-color:rgba(191,168,137,.75);
      box-shadow:0 0 0 3px var(--ring);
    }

    .color-input{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px;
      border:1px solid var(--border-color);
      border-radius:14px;
      cursor:pointer;
      background:rgba(255,255,255,.55);
      transition:.15s ease;
      color:var(--second-color);
    }
    .color-input:hover{border-color:rgba(191,168,137,.75)}

    .swatch{
      width:40px;height:40px;border:none;border-radius:12px;cursor:pointer;background:#fff;padding:0;
      border:1px solid rgba(0,0,0,.10);
      box-shadow:0 8px 16px rgba(0,0,0,.08);
    }

    .btn{
      width:100%;
      padding:14px;
      border:none;
      border-radius:14px;
      font-size:14px;
      font-weight:900;
      cursor:pointer;
      transition:.15s ease;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      user-select:none;
      min-height:46px;
    }
    .btn:active{transform:translateY(1px)}
    .btn:disabled{opacity:.65;cursor:not-allowed;transform:none}

    .btn-primary{
      background:var(--button-grad);
      color:var(--button-text);
      box-shadow:0 16px 34px rgba(0,0,0,.18);
      border:1px solid rgba(0,0,0,.06);
    }
    .btn-secondary{
      background:rgba(255,255,255,.55);
      color:var(--second-color);
      border:1px solid var(--border-color);
      box-shadow:var(--shadow-sm);
    }
    .btn-outline{
      background:rgba(255,255,255,.55);
      color:var(--second-color);
      border:1px solid var(--border-color);
      box-shadow:var(--shadow-sm);
    }

    .btn-group{display:grid;gap:10px;margin-top:12px}
    .merge-downloads{display:none;gap:10px;margin-top:10px}
    .merge-downloads .btn{ padding:12px 10px; font-size:13px; border-radius:14px; }
    .merge-grid{ display:grid; grid-template-columns:1fr 1fr; gap:10px; }

    .layers{
      border:1px solid var(--border-color);
      border-radius:16px;
      background:rgba(255,255,255,.55);
      overflow:hidden;
    }
    .layer-item{
      display:grid;
      grid-template-columns:54px 1fr 36px;
      gap:10px;
      align-items:center;
      padding:10px;
      border-top:1px solid rgba(0,0,0,.06);
      cursor:pointer;
      transition:.12s ease;
    }
    .layer-item:first-child{border-top:none}
    .layer-item:hover{ background:rgba(191,168,137,.08); }
    .layer-item.active{ background:rgba(191,168,137,.14); }

    .thumb{
      width:54px;height:40px;border-radius:12px;
      background:rgba(0,0,0,.04);
      overflow:hidden;
      border:1px solid rgba(0,0,0,.06);
      display:grid;place-items:center;
    }
    .thumb img{width:100%;height:100%;object-fit:cover}
    .thumb .t{font-weight:900;color:var(--third-color);font-size:16px}

    .layer-meta .name{font-size:13px;font-weight:900;color:var(--second-color)}
    .layer-meta .sub{font-size:12px;color:var(--text-color-light);margin-top:2px}

    .trash{
      width:34px;height:34px;border-radius:12px;
      border:1px solid rgba(0,0,0,.10);
      background:rgba(255,255,255,.55);
      cursor:pointer;
      display:grid;place-items:center;
      transition:.12s ease;
    }
    .trash:hover{border-color:rgba(239,68,68,.55);background:rgba(239,68,68,.08)}

    .canvas-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-bottom:12px;
      gap:10px;
      flex-wrap:wrap;
    }
    .canvas-title{
      font-size:1.05rem;
      font-weight:1000;
      color:var(--second-color);
      letter-spacing:-.01em;
    }
    .header-actions{display:flex;gap:10px;align-items:center;flex-wrap:wrap}

    .mini-btn{
      padding:10px 12px;
      border:1px solid var(--border-color);
      border-radius:12px;
      background:rgba(255,255,255,.55);
      color:var(--second-color);
      font-weight:900;
      cursor:pointer;
      transition:.15s ease;
      font-size:13px;
      box-shadow:var(--shadow-sm);
    }
    .mini-btn:disabled{opacity:.55;cursor:not-allowed}
    .mini-btn:hover{transform:translateY(-1px); box-shadow:var(--shadow-md); border-color:rgba(191,168,137,.65)}

    .panel-switch{display:flex;gap:10px;flex-wrap:wrap}
    .panel-btn{
      padding:10px 14px;
      border:1px solid var(--border-color);
      border-radius:12px;
      background:rgba(255,255,255,.55);
      color:var(--second-color);
      font-weight:900;
      cursor:pointer;
      transition:.15s ease;
      font-size:13px;
      box-shadow:var(--shadow-sm);
    }
    .panel-btn:hover{border-color:rgba(191,168,137,.7); transform:translateY(-1px)}
    .panel-btn.active{
      border-color:transparent;
      background:var(--button-grad);
      color:#fff;
      box-shadow:0 16px 34px rgba(0,0,0,.18);
    }

    .outside-toolbar{
      display:none;
      gap:8px;
      align-items:center;
      justify-content:center;
      padding:10px;
      border-radius:999px;
      background:var(--glass);
      border:1px solid var(--glass-bd);
      box-shadow:var(--shadow-md);
      margin:0 auto 14px auto;
      width:max-content;
      user-select:none;
      backdrop-filter: blur(12px) saturate(140%);
      -webkit-backdrop-filter: blur(12px) saturate(140%);
    }
    .canvas-area.has-selection .outside-toolbar{display:flex}

    .toolbtn{
      width:34px;height:34px;border-radius:12px;
      border:1px solid var(--border-color);
      background:rgba(255,255,255,.55);
      display:grid;place-items:center;
      cursor:pointer;
      font-size:14px;font-weight:900;
      user-select:none;
      transition:.12s ease;
      color:var(--second-color);
    }
    .toolbtn:hover{ background:rgba(191,168,137,.10); border-color:rgba(191,168,137,.65) }
    .toolbtn.danger:hover{ background:rgba(239,68,68,.10); border-color:rgba(239,68,68,.55) }

    .canvas-wrapper{
      flex:1;
      display:flex;
      align-items:center;
      justify-content:center;
      background:rgba(0,0,0,.03);
      border:1px solid rgba(0,0,0,.06);
      border-radius:18px;
      padding:34px;
      position:relative;
      min-height:520px;
    }

    .stage{
      width:min(980px, 100%);
      height:min(560px, 100%);
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      gap:18px;
    }

    .canvas-frame{
      background:#fff;
      position:relative;
      overflow:hidden;
      border-radius:12px;
      box-shadow:0 20px 60px rgba(0,0,0,.15);
      cursor:default;
      overscroll-behavior:contain;
      width:100%;
      height:100%;
      max-width:none;
      border:3px dashed rgba(191,168,137,.85);
    }
    .canvas-frame.has-any{ cursor:move; }
    .canvas-frame.focus{
      outline:4px solid rgba(191,168,137,.55);
      outline-offset:6px;
    }
    .canvas-frame.drop-target{
      outline:5px solid rgba(191,168,137,.70);
      outline-offset:6px;
      box-shadow:0 22px 70px rgba(0,0,0,.16);
    }

    .arch-outline{
      position:absolute;
      inset:0;
      pointer-events:none;
      display:none;
    }
    .arch-outline svg{width:100%;height:100%;display:block;}
    .arch-outline path{
      fill:none;
      stroke: rgba(191,168,137,.95);
      stroke-width: 6;
      stroke-dasharray: 14 12;
      vector-effect: non-scaling-stroke;
      transform-box: fill-box;
      transform-origin: 50% 50%;
    }

    .canvas-frame.arch{
      border-radius:0;
      border:none;
    }
    .canvas-frame.arch .arch-outline{ display:block; }

    .layer-wrap{
      position:absolute;top:50%;left:50%;
      transform-origin:center;display:none;
      user-select:none;-webkit-user-drag:none;pointer-events:auto;
    }
    .layer-wrap.selected{
      outline:3px solid rgba(191,168,137,.55);
      outline-offset:8px;
      border-radius:10px
    }

    .layer-img{
      display:block;
      max-width:none;
      user-select:none;
      -webkit-user-drag:none;
      pointer-events:none;
    }

    .layer-textbox{
      white-space:pre-wrap;
      text-align:center;
      font-weight:900;
      pointer-events:none;
      border-radius:12px;
      border:1px solid rgba(191,168,137,.55);
      padding:12px 20px;
      box-shadow:0 10px 24px rgba(0,0,0,.12);
      max-width:720px;
      color:#121212;
      background:rgba(255,255,255,.85);
    }

    .empty-state{
      position:absolute;inset:0;
      display:none;flex-direction:column;
      align-items:center;justify-content:center;
      color:var(--text-color-light);
      pointer-events:none
    }

    /* Arch flip buttons */
    .arch-tools{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    .arch-tool{
      padding:12px 12px;
      border:1px solid var(--border-color);
      border-radius:14px;
      background:rgba(255,255,255,.55);
      font-weight:1000;
      font-size:13px;
      color:var(--second-color);
      cursor:pointer;
      box-shadow:var(--shadow-sm);
      transition:.12s ease;
      user-select:none;
    }
    .arch-tool:hover{transform:translateY(-1px); box-shadow:var(--shadow-md); border-color:rgba(191,168,137,.65)}
    .arch-tool.active{
      background:var(--button-grad);
      color:#fff;
      border-color:transparent;
      box-shadow:0 16px 34px rgba(0,0,0,.18);
    }
    .arch-tool.full{grid-column:1 / -1;}

    /* Library */
    .library{
      border:1px solid var(--border-color);
      border-radius:16px;
      background:rgba(255,255,255,.55);
      overflow:hidden;
      margin-top:10px;
    }
    .library-head{
      padding:10px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      border-bottom:1px solid rgba(0,0,0,.06);
      font-weight:1000;
      font-size:13px;
      color:var(--second-color);
    }
    .library-count{ color:var(--third-color); font-weight:1000; }
    .library-grid{
      display:grid;
      grid-template-columns:repeat(3, 1fr);
      gap:10px;
      padding:12px;
    }
    .lib-item{
      border:1px solid rgba(0,0,0,.08);
      border-radius:14px;
      overflow:hidden;
      background:rgba(255,255,255,.7);
      box-shadow:0 10px 20px rgba(0,0,0,.08);
      cursor:grab;
      user-select:none;
      position:relative;
      aspect-ratio: 1 / 1;
      display:grid;
      place-items:center;
    }
    .lib-item:active{cursor:grabbing}
    .lib-item img{width:100%;height:100%;object-fit:cover;display:block}
    .lib-x{
      position:absolute;
      top:6px; right:6px;
      width:26px;height:26px;
      border-radius:10px;
      border:1px solid rgba(0,0,0,.12);
      background:rgba(255,255,255,.78);
      display:grid; place-items:center;
      font-weight:1000;
      cursor:pointer;
    }
    .lib-x:hover{ background:rgba(239,68,68,.10); border-color:rgba(239,68,68,.45); }

    .hexpicker-pop{
      position:fixed;
      z-index:9999;
      width:320px;
      background:#fff;
      border:1px solid rgba(0,0,0,.18);
      border-radius:12px;
      box-shadow:0 18px 50px rgba(0,0,0,.18);
      overflow:hidden;
      font-family:var(--body-font);
      user-select:none;
    }
    .hexpicker-top{padding:12px 12px 0 12px;}
    .hexpicker-sv{
      width:100%;
      height:170px;
      border-radius:8px;
      position:relative;
      overflow:hidden;
      background:red;
      cursor:crosshair;
      border:1px solid rgba(0,0,0,.08);
    }
    .hexpicker-sv::before{
      content:"";
      position:absolute; inset:0;
      background: linear-gradient(to right, #fff, rgba(255,255,255,0));
    }
    .hexpicker-sv::after{
      content:"";
      position:absolute; inset:0;
      background: linear-gradient(to top, #000, rgba(0,0,0,0));
      pointer-events:none;
    }
    .hexpicker-dot{
      position:absolute;
      width:14px;height:14px;
      border-radius:50%;
      border:2px solid #fff;
      box-shadow:0 4px 12px rgba(0,0,0,.25);
      transform: translate(-7px, -7px);
      pointer-events:none;
    }
    .hexpicker-mid{
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 12px 10px 12px;
    }
    .hexpicker-ico{
      width:28px;height:28px;
      border-radius:8px;
      border:1px solid rgba(0,0,0,.12);
      background:rgba(0,0,0,.03);
      display:grid;place-items:center;
      font-size:14px;
    }
    .hexpicker-preview{
      width:28px;height:28px;
      border-radius:999px;
      border:2px solid #fff;
      outline:1px solid rgba(0,0,0,.18);
      box-shadow:0 6px 14px rgba(0,0,0,.12);
      background:#fff;
    }
    .hexpicker-hue{
      flex:1;
      -webkit-appearance:none;
      height:10px;
      border-radius:999px;
      outline:none;
      cursor:pointer;
      background: linear-gradient(to right,
        #ff0000, #ffff00, #00ff00, #00ffff, #0000ff, #ff00ff, #ff0000
      );
    }
    .hexpicker-hue::-webkit-slider-thumb{
      -webkit-appearance:none;
      width:16px;height:16px;border-radius:50%;
      background:#fff;
      border:1px solid rgba(0,0,0,.18);
      box-shadow:0 6px 14px rgba(0,0,0,.18);
    }
    .hexpicker-bot{
      padding:10px 12px 12px 12px;
      display:grid;
      gap:10px;
    }
    .hexpicker-hex{
      width:100%;
      padding:10px 12px;
      border:1px solid rgba(0,0,0,.18);
      border-radius:8px;
      font-weight:900;
      letter-spacing:.06em;
      text-transform:uppercase;
      outline:none;
      transition: .12s ease;
      font-size:16px;
      text-align:center;
    }
    .hexpicker-row{display:grid;grid-template-columns:1fr;gap:10px;}
    .hexpicker-format{
      width:100%;
      padding:10px 12px;
      border:2px solid #2f6cff22;
      border-radius:8px;
      font-weight:900;
      background:#fff;
      outline:none;
      font-size:15px;
      text-align:center;
    }
    .hexpicker-invalid{
      border-color:rgba(239,68,68,.65)!important;
      box-shadow:0 0 0 3px rgba(239,68,68,.12);
    }

    @media (max-width:1024px){
      .workspace{grid-template-columns:1fr}
      .sidebar{position:relative;top:auto;height:auto;overflow:visible;}
      .tab-content{height:auto;overflow:visible;padding-right:0;}
    }
    @media (max-width:768px){
      body{padding:10px}
      .header h1{font-size:1.25rem}
      .canvas-wrapper{padding:18px}
      .stage{height:min(520px,100%)}
      .hexpicker-pop{ width: 300px; }
      .library-grid{ grid-template-columns:repeat(4, 1fr); }
    }
  </style>
</head>

<body>
  <!-- SVG clip defs: MID-CUT at exactly 50% (top point is centered), rear is true mirror -->
  <svg width="0" height="0" style="position:absolute; left:-9999px; top:-9999px;">
    <defs>
      <!-- FRONT: left diagonal goes to exact middle top -->
      <clipPath id="clipArchFront" clipPathUnits="objectBoundingBox">
        <path id="clipPathFront" d="M0 1 L1 1 L1 0 L0.5 0 Z"></path>
      </clipPath>

      <!-- REAR: mirror of front (right diagonal goes to exact middle top) -->
      <clipPath id="clipArchRear" clipPathUnits="objectBoundingBox">
        <path id="clipPathRear" d="M0 1 L1 1 L0.5 0 L0 0 Z"></path>
      </clipPath>
    </defs>
  </svg>

  <div class="container">
    <div class="header">
      <h1>üöó <span>Vinyl</span> Designer</h1>
      <p>
        <b>Mouse wheel:</b> Zoom ‚Ä¢ <b>Shift + wheel:</b> Rotate ‚Ä¢ <b>Drag:</b> Move selected layer
        <br><b>Add Text:</b> type text ‚Üí click <b>Add Text</b>
        <br><b>Undo/Redo:</b> use the buttons above the canvas
        <br><b>NEW:</b> Upload once ‚Üí drag from <b>Image Library</b> to Front/Rear. Drag layers between panels to move them.
      </p>
    </div>

    <div class="workspace">
      <div class="sidebar" id="sidebar">
        <div class="tab-buttons">
          <button class="tab-btn active" data-tab="design">‚ú® Design</button>
          <button class="tab-btn" data-tab="text">üìù Text</button>
        </div>

        <div class="tab-content active" id="design-tab">
          <div class="section">
            <div class="section-title">Frame Category</div>
            <select class="preset" id="frameTypeSelect" aria-label="Frame Category">
              <option value="regular" selected>Regular Frame</option>
              <option value="arch">Arch Type (Both)</option>
              <option value="mixed">Mixed Frame (Front Regular + Rear Arch)</option>
            </select>
            <div class="mini" id="frameTypeInfo">
              Regular = original rectangle. Arch Type = diagonal cut meets top exactly in the middle.
            </div>
          </div>

          <!-- Arch rotation + flips (affects ONLY selected panel) -->
          <div class="section" id="archRotateSection" style="display:none;">
            <div class="section-title">Arch Tools (Selected Panel Only)</div>

            <div class="control-group" style="margin-top:6px;">
              <div class="control-label">
                <span>Rotate Arch Shape</span>
                <span class="control-value" id="archRotateValue">0¬∞</span>
              </div>
              <input type="range" id="archRotateRange" min="0" max="360" value="0">
              <div class="mini">
                Rotates the <b>arch frame shape</b> only (clip + outline + export). Artwork stays as-is.
                <br><b>Note:</b> In Mixed mode, only Rear is an arch.
              </div>
            </div>

            <div class="arch-tools">
              <button class="arch-tool" id="archFlipXBtn" type="button" title="Flip arch shape left/right">
                ‚Üî Flip Side
              </button>
              <button class="arch-tool" id="archFlipYBtn" type="button" title="Flip arch shape up/down">
                ‚Üï Flip Up/Down
              </button>
              <button class="arch-tool full" id="archResetBtn" type="button" title="Reset arch rotation and flips for selected panel">
                ‚ü≤ Reset Arch (Selected Panel)
              </button>
            </div>

            <div class="mini" id="archPanelInfo"></div>
          </div>

          <div class="section">
            <div class="section-title">Vinyl Size (inches)</div>

            <div class="grid2">
              <div class="field">
                <label>Height (H)</label>
                <input type="number" id="hIn" min="1" step="0.01" value="18">
              </div>
              <div class="field">
                <label>Width (W)</label>
                <input type="number" id="wIn" min="1" step="0.01" value="36">
              </div>
            </div>

            <div class="apply-row">
              <select class="preset" id="presetSelect">
                <option value="">Presets (H√óW)</option>
              </select>

              <button class="btn btn-secondary" id="applySizeBtn" style="width:auto;padding:12px 16px;">
                ‚úÖ Apply
              </button>
            </div>

            <div class="mini" id="sizeInfo"></div>
          </div>

          <div class="section">
            <div class="section-title">Upload Images (Shared Library)</div>
            <div class="upload-zone" id="uploadZone">
              <div style="font-size:34px;margin-bottom:6px;">üñºÔ∏è</div>
              <div style="font-size:14px;margin-bottom:6px;font-weight:900;color:var(--second-color);">Click or drag images here</div>
              <div style="font-size:12px;color:var(--text-color-light);">Supports JPG, PNG, WebP</div>
            </div>
            <input type="file" id="fileInput" accept="image/*" multiple>
            <div class="mini" id="uploadInfo">Uploads go into the Image Library. Drag any image onto Front/Rear to add it.</div>

            <div class="library" id="libraryBox">
              <div class="library-head">
                <span>Image Library</span>
                <span class="library-count" id="libraryCount">0</span>
              </div>
              <div class="library-grid" id="libraryGrid"></div>
            </div>
            <div class="mini">Drag a library thumbnail onto a panel to create a new layer there.</div>
          </div>

          <div class="section">
            <div class="section-title">Frame Background</div>
            <div class="color-input" id="frameBgRow">
              <div style="display:flex;align-items:center;gap:10px;">
                <button class="swatch" id="frameBgSwatch" type="button" aria-label="Frame background color"></button>
                <div style="font-size:12px;font-weight:900;color:var(--text-color-light);">Background</div>
              </div>
              <div style="font-size:12px;font-weight:900;color:var(--text-color-light);" id="frameBgValue">#FFFFFF</div>
            </div>
            <div class="mini">HEX-only picker</div>
          </div>

          <div class="section">
            <div class="section-title">Layers</div>
            <div class="layers" id="layerList"></div>
            <div class="mini">In <b>Merge</b> view: left is Front, right is Rear (mirrored).</div>
          </div>

          <div class="section">
            <div class="section-title">Selected Layer</div>

            <div class="control-group">
              <div class="control-label"><span>Zoom</span><span class="control-value" id="zoomValue">100%</span></div>
              <input type="range" id="zoomRange" min="30" max="400" value="100">
            </div>

            <div class="control-group">
              <div class="control-label"><span>Rotation</span><span class="control-value" id="rotateValue">0¬∞</span></div>
              <input type="range" id="rotateRange" min="-180" max="180" value="0">
            </div>

            <div class="btn-group">
              <button class="btn btn-secondary" id="resetBtn">‚Üª Reset Selected Layer</button>
            </div>
          </div>

          <div class="section" style="margin-top:18px;">
            <button class="btn btn-primary" id="downloadBtn">
              <span>‚¨á</span><span id="downloadLabel">Download JPG</span>
            </button>

            <div class="merge-downloads" id="mergeDownloadGroup">
              <button class="btn btn-primary" id="downloadBothBtn">‚¨á‚¨á Download Both (Front + Rear)</button>
              <div class="merge-grid">
                <button class="btn btn-outline" id="downloadFrontBtn">‚¨á Front JPG</button>
                <button class="btn btn-outline" id="downloadRearBtn">‚¨á Rear JPG</button>
              </div>
            </div>

            <div class="mini">Print at <b>100%</b>. Inches apply to export size.</div>
          </div>
        </div>

        <div class="tab-content" id="text-tab">
          <div class="section">
            <div class="section-title">Text</div>
            <textarea id="textInput" placeholder="Type your text here..."></textarea>
            <div class="btn-group">
              <button class="btn btn-primary" id="addTextBtn">‚ûï Add Text</button>
              <button class="btn btn-secondary" id="updateTextBtn">‚úÖ Update Selected Text</button>
              <button class="btn btn-secondary" id="deleteTextLayerBtn">üóëÔ∏è Delete Selected Text</button>
            </div>
            <div class="mini">Tip: click a text layer on the canvas (or in Layers) to edit it.</div>
          </div>

          <div class="section">
            <div class="section-title">Text Style</div>
            <div class="control-group">
              <div class="control-label"><span>Size</span><span class="control-value" id="textSizeValue">32px</span></div>
              <input type="range" id="textSizeRange" min="12" max="120" value="32">
            </div>
            <div class="control-group">
              <div class="control-label"><span>Background Opacity</span><span class="control-value" id="bgOpacityValue">90%</span></div>
              <input type="range" id="bgOpacityRange" min="0" max="100" value="90">
            </div>
          </div>

          <div class="section">
            <div class="section-title">Colors</div>

            <div class="color-input" id="textColorRow" style="margin-bottom:10px;">
              <div style="display:flex;align-items:center;gap:10px;">
                <button class="swatch" id="textColorSwatch" type="button" aria-label="Text color"></button>
                <div style="font-size:12px;font-weight:900;color:var(--text-color-light);">Text</div>
              </div>
              <div style="font-size:12px;font-weight:900;color:var(--text-color-light);" id="textColorValue">#000000</div>
            </div>

            <div class="color-input" id="bgColorRow">
              <div style="display:flex;align-items:center;gap:10px;">
                <button class="swatch" id="bgColorSwatch" type="button" aria-label="Text background color"></button>
                <div style="font-size:12px;font-weight:900;color:var(--text-color-light);">Background</div>
              </div>
              <div style="font-size:12px;font-weight:900;color:var(--text-color-light);" id="bgColorValue">#FFFFFF</div>
            </div>

            <div class="mini">All pickers are HEX-only.</div>
          </div>
        </div>
      </div>

      <div class="canvas-area" id="canvasArea">
        <div class="canvas-header">
          <div class="canvas-title" id="canvasTitle">Front Panel</div>

          <div class="header-actions">
            <button class="mini-btn" id="undoBtn" title="Undo">‚Ü© Undo</button>
            <button class="mini-btn" id="redoBtn" title="Redo">‚Ü™ Redo</button>

            <div class="panel-switch">
              <button class="panel-btn active" data-panel="front">Front Panel</button>
              <button class="panel-btn" data-panel="rear">Rear Panel</button>
              <button class="panel-btn" data-panel="merge">Merge</button>
            </div>
          </div>
        </div>

        <div class="outside-toolbar" id="outsideToolbar">
          <div class="toolbtn" id="tb_back"  title="Send to back">‚á©</div>
          <div class="toolbtn" id="tb_down"  title="Backward one">‚Üì</div>
          <div class="toolbtn" id="tb_up"    title="Forward one">‚Üë</div>
          <div class="toolbtn" id="tb_front" title="Bring to front">‚áß</div>
          <div class="toolbtn" id="tb_rotL"  title="Rotate left (10¬∞)">‚ü≤</div>
          <div class="toolbtn" id="tb_rotR"  title="Rotate right (10¬∞)">‚ü≥</div>
          <div class="toolbtn danger" id="tb_del" title="Delete">üóëÔ∏è</div>
        </div>

        <div class="canvas-wrapper">
          <div class="stage" id="stage">
            <div class="canvas-frame focus" id="panelFront">
              <div class="arch-outline" aria-hidden="true">
                <svg viewBox="0 0 1000 500" preserveAspectRatio="none">
                  <!-- MID-CUT: meets top at 500 (center) -->
                  <path id="archPathFront" d="M0 500 L1000 500 L1000 0 L500 0 Z"></path>
                </svg>
              </div>

              <div id="stackFront"></div>
              <div class="empty-state" id="emptyFront" style="display:flex;">
                <div style="font-size:56px;margin-bottom:12px;opacity:.5;">üé®</div>
                <div style="font-size:15px;font-weight:1000;color:var(--second-color);">Upload images or add text</div>
              </div>
            </div>

            <div class="canvas-frame" id="panelRear" style="display:none;">
              <div class="arch-outline" aria-hidden="true">
                <svg viewBox="0 0 1000 500" preserveAspectRatio="none">
                  <!-- MID-CUT mirror -->
                  <path id="archPathRear" d="M0 500 L1000 500 L500 0 L0 0 Z"></path>
                </svg>
              </div>

              <div id="stackRear"></div>
              <div class="empty-state" id="emptyRear" style="display:flex;">
                <div style="font-size:56px;margin-bottom:12px;opacity:.5;">üé®</div>
                <div style="font-size:15px;font-weight:1000;color:var(--second-color);">Upload images or add text</div>
              </div>
            </div>
          </div>
        </div>

      </div>
    </div>
  </div>

<script>
  /* ============================
     HEX-only picker
     ============================ */
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

  function normalizeHex(v){
    v = (v || '').trim();
    if (!v) return null;
    if (!v.startsWith('#')) v = '#' + v;
    if (/^#[0-9a-fA-F]{3}$/.test(v)){
      v = '#' + v[1]+v[1] + v[2]+v[2] + v[3]+v[3];
    }
    if (!/^#[0-9a-fA-F]{6}$/.test(v)) return null;
    return v.toUpperCase();
  }

  function rgbToHex(r,g,b){
    const h = (n)=> n.toString(16).padStart(2,'0');
    return ('#' + h(r) + h(g) + h(b)).toUpperCase();
  }
  function hexToRgb(hex){
    let h = (hex || "#FFFFFF").replace("#","").trim();
    if (h.length === 3) h = h.split("").map(c=>c+c).join("");
    if (h.length !== 6) h = "FFFFFF";
    return { r: parseInt(h.slice(0,2),16), g: parseInt(h.slice(2,4),16), b: parseInt(h.slice(4,6),16) };
  }
  function rgbToHsv(r,g,b){
    r/=255; g/=255; b/=255;
    const max=Math.max(r,g,b), min=Math.min(r,g,b);
    const d=max-min;
    let h=0;
    if (d!==0){
      if (max===r) h=((g-b)/d)%6;
      else if (max===g) h=(b-r)/d+2;
      else h=(r-g)/d+4;
      h*=60;
      if (h<0) h+=360;
    }
    const s = max===0 ? 0 : d/max;
    const v = max;
    return {h,s,v};
  }
  function hsvToRgb(h,s,v){
    const c=v*s;
    const x=c*(1-Math.abs(((h/60)%2)-1));
    const m=v-c;
    let r=0,g=0,b=0;
    if (h>=0 && h<60){ r=c; g=x; b=0; }
    else if (h<120){ r=x; g=c; b=0; }
    else if (h<180){ r=0; g=c; b=x; }
    else if (h<240){ r=0; g=x; b=c; }
    else if (h<300){ r=x; g=0; b=c; }
    else { r=c; g=0; b=x; }
    return {
      r: Math.round((r+m)*255),
      g: Math.round((g+m)*255),
      b: Math.round((b+m)*255)
    };
  }

  class HexOnlyPicker {
    constructor({anchorEl, initialHex="#FFFFFF", onChange}) {
      this.anchorEl = anchorEl;
      this.onChange = onChange;
      const init = normalizeHex(initialHex) || "#FFFFFF";
      const {r,g,b} = hexToRgb(init);
      this.hsv = rgbToHsv(r,g,b);

      this.root = null; this.dot=null; this.sv=null; this.hue=null;
      this.preview=null; this.hexInput=null;

      this._onDocDown = (e)=>{
        if (!this.root) return;
        if (this.root.contains(e.target)) return;
        if (this.anchorEl.contains(e.target)) return;
        this.close();
      };
      this._onKey = (e)=>{ if (e.key === "Escape") this.close(); };
    }

    open(){
      if (this.root) return;
      this.root = document.createElement('div');
      this.root.className = 'hexpicker-pop';
      this.root.innerHTML = `
        <div class="hexpicker-top">
          <div class="hexpicker-sv" tabindex="0" aria-label="Saturation Value">
            <div class="hexpicker-dot"></div>
          </div>
        </div>
        <div class="hexpicker-mid">
          <div class="hexpicker-ico">‚úé</div>
          <div class="hexpicker-preview"></div>
          <input class="hexpicker-hue" type="range" min="0" max="360" value="0" aria-label="Hue">
        </div>
        <div class="hexpicker-bot">
          <input class="hexpicker-hex" value="#FFFFFF" aria-label="HEX">
          <div class="hexpicker-row">
            <select class="hexpicker-format" aria-label="Format">
              <option value="HEX">HEX</option>
            </select>
          </div>
        </div>
      `;
      document.body.appendChild(this.root);

      this.sv = this.root.querySelector('.hexpicker-sv');
      this.dot = this.root.querySelector('.hexpicker-dot');
      this.hue = this.root.querySelector('.hexpicker-hue');
      this.preview = this.root.querySelector('.hexpicker-preview');
      this.hexInput = this.root.querySelector('.hexpicker-hex');

      const r = this.anchorEl.getBoundingClientRect();
      const pad = 10;
      let left = r.left;
      let top = r.bottom + 8;

      const w = 320, h = 290;
      if (left + w > window.innerWidth - pad) left = window.innerWidth - pad - w;
      if (top + h > window.innerHeight - pad) top = r.top - h - 8;
      left = clamp(left, pad, window.innerWidth - pad - w);
      top = clamp(top, pad, window.innerHeight - pad - h);

      this.root.style.left = Math.round(left) + 'px';
      this.root.style.top  = Math.round(top) + 'px';

      this.hue.value = Math.round(this.hsv.h);
      this._syncUIFromHSV(true);

      this.hue.addEventListener('input', ()=>{
        this.hsv.h = parseFloat(this.hue.value);
        this._syncUIFromHSV();
      });

      const onSV = (clientX, clientY)=>{
        const rect = this.sv.getBoundingClientRect();
        const x = clamp(clientX - rect.left, 0, rect.width);
        const y = clamp(clientY - rect.top, 0, rect.height);
        this.hsv.s = rect.width ? x / rect.width : 0;
        this.hsv.v = rect.height ? 1 - (y / rect.height) : 1;
        this._syncUIFromHSV();
      };

      let dragging = false;
      this.sv.addEventListener('mousedown', (e)=>{ dragging=true; onSV(e.clientX, e.clientY); });
      document.addEventListener('mousemove', (e)=>{ if(dragging) onSV(e.clientX, e.clientY); });
      document.addEventListener('mouseup', ()=>{ dragging=false; });

      this.sv.addEventListener('touchstart', (e)=>{ const t=e.touches[0]; if(t) onSV(t.clientX,t.clientY); }, {passive:true});
      this.sv.addEventListener('touchmove', (e)=>{ const t=e.touches[0]; if(t) onSV(t.clientX,t.clientY); }, {passive:true});

      this.hexInput.addEventListener('input', ()=>{
        const hex = normalizeHex(this.hexInput.value);
        this.hexInput.classList.toggle('hexpicker-invalid', !hex);
        if (!hex) return;
        const {r,g,b} = hexToRgb(hex);
        this.hsv = rgbToHsv(r,g,b);
        this.hue.value = Math.round(this.hsv.h);
        this._syncUIFromHSV(false, true);
      });

      setTimeout(()=> {
        document.addEventListener('mousedown', this._onDocDown);
        document.addEventListener('keydown', this._onKey);
      }, 0);
    }

    close(){
      if (!this.root) return;
      document.removeEventListener('mousedown', this._onDocDown);
      document.removeEventListener('keydown', this._onKey);
      this.root.remove();
      this.root = null;
    }

    _syncUIFromHSV(callChange=true, fromHex=false){
      const hueRgb = hsvToRgb(this.hsv.h, 1, 1);
      this.sv.style.background = `rgb(${hueRgb.r},${hueRgb.g},${hueRgb.b})`;

      const rect = this.sv.getBoundingClientRect();
      const w = rect.width || 320;
      const h = rect.height || 170;
      const x = this.hsv.s * w;
      const y = (1 - this.hsv.v) * h;
      this.dot.style.left = `${x}px`;
      this.dot.style.top  = `${y}px`;

      const rgb = hsvToRgb(this.hsv.h, this.hsv.s, this.hsv.v);
      const hex = rgbToHex(rgb.r, rgb.g, rgb.b);
      this.preview.style.background = hex;

      if (!fromHex){
        this.hexInput.classList.remove('hexpicker-invalid');
        this.hexInput.value = hex;
      }

      if (callChange && typeof this.onChange === 'function'){
        this.onChange(hex);
      }
    }
  }

  /* ============================
     App
     ============================ */
  const PANEL = { FRONT:'front', REAR:'rear', MERGE:'merge' };
  const FRAME_TYPE = { REGULAR:'regular', ARCH:'arch', MIXED:'mixed' };

  const PRESETS_REGULAR = [
    {h:12,w:24},{h:16,w:36},{h:18,w:36},{h:18,w:40},{h:24,w:24},{h:24,w:36},{h:24,w:40}
  ];
  const PRESETS_ARCH = [
    {h:16,w:36},{h:18,w:36},{h:18,w:40},{h:24,w:40}
  ];

  let currentView = PANEL.FRONT;
  let editPanel = PANEL.FRONT;

  let magnetW = 36, magnetH = 18;
  let frameType = FRAME_TYPE.REGULAR;

  // per-panel arch transform state (rotate + flipX + flipY)
  const archXform = {
    [PANEL.FRONT]: { rot: 0, flipX: false, flipY: false },
    [PANEL.REAR]:  { rot: 0, flipX: false, flipY: false }
  };

  // NEW: shared image library
  const imageLibrary = []; // { libId, src, name, naturalW, naturalH }

  const state = {
    [PANEL.FRONT]: { layers: [], selectedId: null, bgColor:"#FFFFFF" },
    [PANEL.REAR]:  { layers: [], selectedId: null, bgColor:"#FFFFFF" }
  };

  const lastFrameSize = {
    [PANEL.FRONT]: { w: 0, h: 0 },
    [PANEL.REAR]:  { w: 0, h: 0 }
  };

  const history = [];
  const redoStack = [];
  let applyingHistory = false;

  let moving=false, startX=0,startY=0,startLX=0,startLY=0;

  const el = {
    tabBtns: document.querySelectorAll('.tab-btn'),
    tabContents: document.querySelectorAll('.tab-content'),

    frameTypeSelect: document.getElementById('frameTypeSelect'),
    frameTypeInfo: document.getElementById('frameTypeInfo'),

    archRotateSection: document.getElementById('archRotateSection'),
    archRotateRange: document.getElementById('archRotateRange'),
    archRotateValue: document.getElementById('archRotateValue'),
    archFlipXBtn: document.getElementById('archFlipXBtn'),
    archFlipYBtn: document.getElementById('archFlipYBtn'),
    archResetBtn: document.getElementById('archResetBtn'),
    archPanelInfo: document.getElementById('archPanelInfo'),

    hIn: document.getElementById('hIn'),
    wIn: document.getElementById('wIn'),
    presetSelect: document.getElementById('presetSelect'),
    applySizeBtn: document.getElementById('applySizeBtn'),
    sizeInfo: document.getElementById('sizeInfo'),

    uploadZone: document.getElementById('uploadZone'),
    fileInput: document.getElementById('fileInput'),
    uploadInfo: document.getElementById('uploadInfo'),

    libraryGrid: document.getElementById('libraryGrid'),
    libraryCount: document.getElementById('libraryCount'),

    layerList: document.getElementById('layerList'),

    frameBgRow: document.getElementById('frameBgRow'),
    frameBgSwatch: document.getElementById('frameBgSwatch'),
    frameBgValue: document.getElementById('frameBgValue'),

    zoomRange: document.getElementById('zoomRange'),
    rotateRange: document.getElementById('rotateRange'),
    zoomValue: document.getElementById('zoomValue'),
    rotateValue: document.getElementById('rotateValue'),
    resetBtn: document.getElementById('resetBtn'),

    textInput: document.getElementById('textInput'),
    textSizeRange: document.getElementById('textSizeRange'),
    bgOpacityRange: document.getElementById('bgOpacityRange'),
    textSizeValue: document.getElementById('textSizeValue'),
    bgOpacityValue: document.getElementById('bgOpacityValue'),

    textColorRow: document.getElementById('textColorRow'),
    bgColorRow: document.getElementById('bgColorRow'),
    textColorSwatch: document.getElementById('textColorSwatch'),
    bgColorSwatch: document.getElementById('bgColorSwatch'),
    textColorValue: document.getElementById('textColorValue'),
    bgColorValue: document.getElementById('bgColorValue'),

    addTextBtn: document.getElementById('addTextBtn'),
    updateTextBtn: document.getElementById('updateTextBtn'),
    deleteTextLayerBtn: document.getElementById('deleteTextLayerBtn'),

    downloadBtn: document.getElementById('downloadBtn'),
    downloadLabel: document.getElementById('downloadLabel'),
    mergeDownloadGroup: document.getElementById('mergeDownloadGroup'),
    downloadBothBtn: document.getElementById('downloadBothBtn'),
    downloadFrontBtn: document.getElementById('downloadFrontBtn'),
    downloadRearBtn: document.getElementById('downloadRearBtn'),

    canvasTitle: document.getElementById('canvasTitle'),
    canvasArea: document.getElementById('canvasArea'),

    stage: document.getElementById('stage'),
    panelFront: document.getElementById('panelFront'),
    panelRear: document.getElementById('panelRear'),
    stackFront: document.getElementById('stackFront'),
    stackRear: document.getElementById('stackRear'),
    emptyFront: document.getElementById('emptyFront'),
    emptyRear: document.getElementById('emptyRear'),

    tb_back: document.getElementById('tb_back'),
    tb_down: document.getElementById('tb_down'),
    tb_up: document.getElementById('tb_up'),
    tb_front: document.getElementById('tb_front'),
    tb_rotL: document.getElementById('tb_rotL'),
    tb_rotR: document.getElementById('tb_rotR'),
    tb_del: document.getElementById('tb_del'),

    undoBtn: document.getElementById('undoBtn'),
    redoBtn: document.getElementById('redoBtn'),

    clipPathFront: document.getElementById('clipPathFront'),
    clipPathRear: document.getElementById('clipPathRear'),
    archPathFront: document.getElementById('archPathFront'),
    archPathRear: document.getElementById('archPathRear'),
  };

  function s(panelKey=editPanel){ return state[panelKey]; }
  function frame(panelKey){ return panelKey === PANEL.FRONT ? el.panelFront : el.panelRear; }
  function stack(panelKey){ return panelKey === PANEL.FRONT ? el.stackFront : el.stackRear; }
  function empty(panelKey){ return panelKey === PANEL.FRONT ? el.emptyFront : el.emptyRear; }

  function isArchPanel(panelKey){
    if (frameType === FRAME_TYPE.ARCH) return true;
    if (frameType === FRAME_TYPE.MIXED) return panelKey === PANEL.REAR;
    return false;
  }

  function selectedLayer(panelKey=editPanel){
    const id = s(panelKey).selectedId;
    return s(panelKey).layers.find(l => l.id === id) || null;
  }
  function getLayer(panelKey, id){
    return s(panelKey).layers.find(l => l.id === id) || null;
  }

  function uid(){ return 'L' + Math.random().toString(16).slice(2) + Date.now().toString(16); }
  function libUid(){ return 'I' + Math.random().toString(16).slice(2) + Date.now().toString(16); }

  function normalizeDeg(d){
    let x = d % 360;
    if (x > 180) x -= 360;
    if (x < -180) x += 360;
    return x;
  }
  function normalize360(d){
    return ((d % 360) + 360) % 360;
  }

  /* ============================
     Drag & Drop payload
     ============================ */
  const DND = {
    mime: 'application/x-vinyl-dnd',
    make(payload){ return JSON.stringify(payload); },
    parse(data){ try{ return JSON.parse(data); } catch { return null; } }
  };

  /* ============================
     apply arch transform
     ============================ */
  function applyArchTransform(panelKey){
    const xf = archXform[panelKey];
    const deg = normalize360(xf.rot);
    const sx = xf.flipX ? -1 : 1;
    const sy = xf.flipY ? -1 : 1;

    const clipEl = (panelKey === PANEL.FRONT) ? el.clipPathFront : el.clipPathRear;
    if (clipEl && isArchPanel(panelKey)){
      clipEl.setAttribute(
        'transform',
        `translate(0.5 0.5) rotate(${deg}) scale(${sx} ${sy}) translate(-0.5 -0.5)`
      );
    } else if (clipEl){
      clipEl.removeAttribute('transform');
    }

    const pathEl = (panelKey === PANEL.FRONT) ? el.archPathFront : el.archPathRear;
    if (pathEl && isArchPanel(panelKey)){
      pathEl.setAttribute(
        'transform',
        `translate(500 250) rotate(${deg}) scale(${sx} ${sy}) translate(-500 -250)`
      );
    } else if (pathEl){
      pathEl.removeAttribute('transform');
    }
  }

  function updateArchUI(){
    const archHere = isArchPanel(editPanel);
    const xf = archXform[editPanel];

    el.archPanelInfo.innerHTML = archHere
      ? `Editing <b>${editPanel === PANEL.FRONT ? 'Front' : 'Rear'}</b> arch. Changes apply to this panel only.`
      : `Selected panel (<b>${editPanel === PANEL.FRONT ? 'Front' : 'Rear'}</b>) is <b>Regular</b> right now ‚Äî arch tools won‚Äôt affect it.`;

    el.archRotateRange.disabled = !archHere;
    el.archFlipXBtn.disabled = !archHere;
    el.archFlipYBtn.disabled = !archHere;
    el.archResetBtn.disabled = !archHere;

    const deg = normalize360(xf.rot);
    el.archRotateRange.value = Math.round(deg);
    el.archRotateValue.textContent = Math.round(deg) + '¬∞';

    el.archFlipXBtn.classList.toggle('active', !!xf.flipX);
    el.archFlipYBtn.classList.toggle('active', !!xf.flipY);
  }

  function fillPresets(){
    const list = (frameType === FRAME_TYPE.ARCH) ? PRESETS_ARCH : PRESETS_REGULAR;
    el.presetSelect.innerHTML = `<option value="">Presets (H√óW)</option>` + list
      .map(p => `<option value="${p.h}x${p.w}">${p.h}√ó${p.w}</option>`)
      .join("");
  }

  function applyFrameType(){
    const front = frame(PANEL.FRONT);
    const rear  = frame(PANEL.REAR);

    front.classList.remove('arch');
    rear.classList.remove('arch');
    front.style.clipPath = 'none';
    rear.style.clipPath  = 'none';

    if (frameType === FRAME_TYPE.ARCH){
      front.classList.add('arch');
      rear.classList.add('arch');
      front.style.clipPath = 'url(#clipArchFront)';
      rear.style.clipPath  = 'url(#clipArchRear)';

      el.frameTypeInfo.textContent =
        "Arch Type (Both): diagonal cut meets top exactly in the middle. Merge: left Front, right Rear (mirror).";

      el.archRotateSection.style.display = 'block';
    }
    else if (frameType === FRAME_TYPE.MIXED){
      rear.classList.add('arch');
      rear.style.clipPath  = 'url(#clipArchRear)';

      el.frameTypeInfo.textContent =
        "Mixed Frame: Front is Regular (rectangle). Rear is Arch (mirror) with mid-cut.";

      el.archRotateSection.style.display = 'block';
    }
    else {
      el.frameTypeInfo.textContent =
        "Regular: original rectangle frame (all presets available).";

      el.archRotateSection.style.display = 'none';
    }

    applyArchTransform(PANEL.FRONT);
    applyArchTransform(PANEL.REAR);
    updateArchUI();

    fillPresets();
    fitFrames(true);
    refitAll();
    pushHistory();
  }

  function stripLayer(l){
    if (l.type === 'image'){
      return {
        id:l.id,type:l.type,name:l.name,
        x:l.x,y:l.y,scale:l.scale,rotation:l.rotation,
        src:l.src,naturalW:l.naturalW,naturalH:l.naturalH
      };
    }
    return {
      id:l.id,type:l.type,name:l.name,
      x:l.x,y:l.y,scale:l.scale,rotation:l.rotation,
      text: {...l.text}
    };
  }

  function snapshotState(){
    return JSON.stringify({
      magnetW, magnetH, currentView, editPanel, frameType,
      archXform,
      lastFrameSize,
      imageLibrary, // NEW
      state: {
        [PANEL.FRONT]: {
          selectedId: state[PANEL.FRONT].selectedId,
          bgColor: state[PANEL.FRONT].bgColor,
          layers: state[PANEL.FRONT].layers.map(stripLayer)
        },
        [PANEL.REAR]: {
          selectedId: state[PANEL.REAR].selectedId,
          bgColor: state[PANEL.REAR].bgColor,
          layers: state[PANEL.REAR].layers.map(stripLayer)
        }
      }
    });
  }

  function updateUndoRedoButtons(){
    el.undoBtn.disabled = history.length <= 1;
    el.redoBtn.disabled = redoStack.length === 0;
  }
  function pushHistory(){
    if (applyingHistory) return;
    history.push(snapshotState());
    if (history.length > 60) history.shift();
    redoStack.length = 0;
    updateUndoRedoButtons();
  }

  function applyFrameBg(panelKey){
    frame(panelKey).style.background = s(panelKey).bgColor;
  }

  function setTitle(){
    const label = (currentView === PANEL.FRONT) ? "Front Panel" :
                  (currentView === PANEL.REAR)  ? "Rear Panel"  : "Merge";
    const editLabel = (currentView === PANEL.MERGE) ? ` ‚Ä¢ editing: ${editPanel === PANEL.FRONT ? "Front" : "Rear"}` : "";

    const typeLabel =
      frameType === FRAME_TYPE.ARCH  ? `Arch (Both)` :
      frameType === FRAME_TYPE.MIXED ? `Mixed (Rear Arch)` :
      "Regular";

    const xf = archXform[editPanel];
    const archBits = isArchPanel(editPanel)
      ? ` ‚Ä¢ Arch: ${Math.round(normalize360(xf.rot))}¬∞${xf.flipX ? " ‚Ä¢ FlipX" : ""}${xf.flipY ? " ‚Ä¢ FlipY" : ""}`
      : "";

    el.canvasTitle.textContent = `${label}${editLabel} ‚Ä¢ ${magnetH}√ó${magnetW} in ‚Ä¢ ${typeLabel}${archBits}`;
  }

  function sanitizeInches(x){
    const v = parseFloat(x);
    if (!Number.isFinite(v)) return null;
    return Math.round(v * 100) / 100;
  }

  el.tabBtns.forEach(btn=>{
    btn.addEventListener('click', ()=>{
      el.tabBtns.forEach(b=>b.classList.remove('active'));
      el.tabContents.forEach(c=>c.classList.remove('active'));
      btn.classList.add('active');
      document.getElementById(btn.dataset.tab + '-tab').classList.add('active');
    });
  });

  /* Arch tools */
  el.archRotateRange.addEventListener('input', ()=>{
    if (!isArchPanel(editPanel)) return;
    pushHistory();
    archXform[editPanel].rot = parseInt(el.archRotateRange.value, 10) || 0;
    applyArchTransform(editPanel);
    updateArchUI();
    setTitle();
    pushHistory();
  });

  el.archFlipXBtn.addEventListener('click', ()=>{
    if (!isArchPanel(editPanel)) return;
    pushHistory();
    archXform[editPanel].flipX = !archXform[editPanel].flipX;
    applyArchTransform(editPanel);
    updateArchUI();
    setTitle();
    pushHistory();
  });

  el.archFlipYBtn.addEventListener('click', ()=>{
    if (!isArchPanel(editPanel)) return;
    pushHistory();
    archXform[editPanel].flipY = !archXform[editPanel].flipY;
    applyArchTransform(editPanel);
    updateArchUI();
    setTitle();
    pushHistory();
  });

  el.archResetBtn.addEventListener('click', ()=>{
    if (!isArchPanel(editPanel)) return;
    pushHistory();
    archXform[editPanel] = { rot: 0, flipX: false, flipY: false };
    applyArchTransform(editPanel);
    updateArchUI();
    setTitle();
    pushHistory();
  });

  function fitFrameToBox(panelEl, boxRect){
    const ratio = magnetW / magnetH;
    const maxW = Math.max(100, boxRect.width);
    const maxH = Math.max(100, boxRect.height);

    let frameW = maxW;
    let frameH = frameW / ratio;

    if (frameH > maxH){
      frameH = maxH;
      frameW = frameH * ratio;
    }

    panelEl.style.width = Math.round(frameW) + 'px';
    panelEl.style.height = Math.round(frameH) + 'px';
  }

  function fitImageBaseToFrame(panelKey, layer){
    if (!layer || layer.type !== 'image') return;
    const fr = frame(panelKey).getBoundingClientRect();
    const natW = layer.naturalW || layer.img?.naturalWidth || 1;
    const natH = layer.naturalH || layer.img?.naturalHeight || 1;
    const fit = Math.min(fr.width / natW, fr.height / natH);
    layer.img.style.width = Math.max(1, Math.round(natW * fit)) + 'px';
    layer.img.style.height = Math.max(1, Math.round(natH * fit)) + 'px';
  }

  function rescaleLayersToNewFrame(panelKey, oldW, oldH, newW, newH){
    if (!oldW || !oldH || !newW || !newH) return;
    const rx = newW / oldW;
    const ry = newH / oldH;
    const rText = (rx + ry) / 2;

    state[panelKey].layers.forEach(l=>{
      l.x *= rx;
      l.y *= ry;
      if (l.type === 'text' && l.text){
        l.text.fontPx = Math.max(1, Math.round((l.text.fontPx || 32) * rText));
      }
    });
  }

  function fitFrames(forceNoRescale=false){
    const oldFrontW = lastFrameSize[PANEL.FRONT].w || frame(PANEL.FRONT).getBoundingClientRect().width || 0;
    const oldFrontH = lastFrameSize[PANEL.FRONT].h || frame(PANEL.FRONT).getBoundingClientRect().height || 0;
    const oldRearW  = lastFrameSize[PANEL.REAR].w  || frame(PANEL.REAR).getBoundingClientRect().width  || 0;
    const oldRearH  = lastFrameSize[PANEL.REAR].h  || frame(PANEL.REAR).getBoundingClientRect().height || 0;

    const r = el.stage.getBoundingClientRect();
    if (currentView === PANEL.MERGE){
      const gap = 18;
      const half = { width: Math.max(100, (r.width - gap)/2), height: r.height };
      fitFrameToBox(el.panelFront, half);
      fitFrameToBox(el.panelRear, half);
    } else {
      fitFrameToBox(el.panelFront, r);
      fitFrameToBox(el.panelRear, r);
    }

    const nf = frame(PANEL.FRONT).getBoundingClientRect();
    const nr = frame(PANEL.REAR).getBoundingClientRect();

    if (!forceNoRescale && !applyingHistory){
      if (oldFrontW > 0 && oldFrontH > 0) rescaleLayersToNewFrame(PANEL.FRONT, oldFrontW, oldFrontH, nf.width, nf.height);
      if (oldRearW  > 0 && oldRearH  > 0) rescaleLayersToNewFrame(PANEL.REAR,  oldRearW,  oldRearH,  nr.width, nr.height);
    }

    lastFrameSize[PANEL.FRONT] = { w: nf.width, h: nf.height };
    lastFrameSize[PANEL.REAR]  = { w: nr.width, h: nr.height };

    [PANEL.FRONT, PANEL.REAR].forEach(pk=>{
      state[pk].layers.forEach(l=>{
        if (l.type === 'image') fitImageBaseToFrame(pk, l);
      });
    });
  }

  function renderLayerTransform(layer){
    layer.wrap.style.transform =
      `translate(-50%, -50%) translate(${layer.x}px, ${layer.y}px) rotate(${layer.rotation}deg) scale(${layer.scale})`;
  }
  function renderTextLayer(layer){
    const t = layer.text;
    layer.textEl.textContent = t.value || '';
    layer.textEl.style.fontSize = (t.fontPx || 32) + 'px';
    layer.textEl.style.color = t.color || '#000';
    const rgb = hexToRgb(t.bg || '#fff');
    layer.textEl.style.background = `rgba(${rgb.r},${rgb.g},${rgb.b},${t.bgOpacity ?? 0.9})`;
  }
  function updateEmpty(panelKey){
    const hasAny = s(panelKey).layers.length > 0;
    empty(panelKey).style.display = hasAny ? 'none' : 'flex';
    frame(panelKey).classList.toggle('has-any', hasAny);
  }
  function refitAll(){
    [PANEL.FRONT, PANEL.REAR].forEach(pk=>{
      state[pk].layers.forEach(l=>{
        if (l.type === 'text') renderTextLayer(l);
        renderLayerTransform(l);
      });
      updateEmpty(pk);
    });
    refreshLayerList();
    updateUIFromSelection();
  }

  function clearSelection(panelKey){
    state[panelKey].selectedId = null;
    state[panelKey].layers.forEach(l => l.wrap?.classList.remove('selected'));
  }
  function setSelected(panelKey, id){
    editPanel = panelKey;
    clearSelection(PANEL.FRONT);
    clearSelection(PANEL.REAR);

    state[panelKey].selectedId = id;
    state[panelKey].layers.forEach(l => l.wrap?.classList.toggle('selected', l.id === id));

    el.panelFront.classList.toggle('focus', editPanel === PANEL.FRONT);
    el.panelRear.classList.toggle('focus', editPanel === PANEL.REAR);

    el.frameBgSwatch.style.background = s(editPanel).bgColor;
    el.frameBgValue.textContent = s(editPanel).bgColor;

    const layer = selectedLayer(editPanel);
    if (layer && layer.type === 'text'){
      el.textInput.value = layer.text.value || "";
      el.textColorSwatch.style.background = layer.text.color || "#000000";
      el.textColorValue.textContent = (layer.text.color || "#000000").toUpperCase();
      el.bgColorSwatch.style.background = layer.text.bg || "#FFFFFF";
      el.bgColorValue.textContent = (layer.text.bg || "#FFFFFF").toUpperCase();
    }

    updateArchUI();
    setTitle();
    updateUIFromSelection();
    refreshLayerList();
  }

  function updateUIFromSelection(){
    const layer = selectedLayer(editPanel);
    el.canvasArea.classList.toggle('has-selection', !!layer);

    if (!layer){
      el.zoomRange.value = 100;
      el.rotateRange.value = 0;
      el.zoomValue.textContent = '100%';
      el.rotateValue.textContent = '0¬∞';
      return;
    }
    el.zoomRange.value = Math.round(layer.scale * 100);
    el.rotateRange.value = Math.round(layer.rotation);
    el.zoomValue.textContent = Math.round(layer.scale * 100) + '%';
    el.rotateValue.textContent = Math.round(layer.rotation) + '¬∞';
  }

  function refreshLayerList(){
    el.layerList.innerHTML = '';
    const list = s(editPanel).layers;

    if (!list.length){
      const row=document.createElement('div');
      row.style.padding='12px';
      row.style.color='var(--text-color-light)';
      row.style.fontWeight='900';
      row.style.fontSize='13px';
      row.textContent='No layers yet.';
      el.layerList.appendChild(row);
      return;
    }

    const uiLayers=[...list].reverse();
    uiLayers.forEach(layer=>{
      const row=document.createElement('div');
      row.className='layer-item'+(layer.id===s(editPanel).selectedId?' active':'');

      const thumb=document.createElement('div');
      thumb.className='thumb';
      if(layer.type==='image'){
        const im=document.createElement('img'); im.src=layer.src; thumb.appendChild(im);
      } else {
        const t=document.createElement('div'); t.className='t'; t.textContent='T'; thumb.appendChild(t);
      }

      const meta=document.createElement('div');
      meta.className='layer-meta';
      const nm=document.createElement('div'); nm.className='name';
      nm.textContent=(layer.type==='text'?'Text':(layer.name||'Image'));

      const sub=document.createElement('div'); sub.className='sub';
      sub.textContent=`Zoom ${Math.round(layer.scale*100)}% ‚Ä¢ Rot ${Math.round(layer.rotation)}¬∞`;

      meta.append(nm,sub);

      const del=document.createElement('button');
      del.className='trash'; del.type='button'; del.textContent='üóëÔ∏è';
      del.addEventListener('click',(e)=>{e.stopPropagation();deleteLayer(editPanel, layer.id);});

      row.addEventListener('click',()=>setSelected(editPanel, layer.id));
      row.append(thumb,meta,del);
      el.layerList.appendChild(row);
    });

    updateEmpty(editPanel);
  }

  function syncDomOrder(panelKey){
    const st = stack(panelKey);
    state[panelKey].layers.forEach(layer => layer.wrap && st.appendChild(layer.wrap));
  }

  function moveLayer(panelKey, layerId, delta){
    pushHistory();
    const list = state[panelKey].layers;
    const i = list.findIndex(l => l.id === layerId);
    const j = i + delta;
    if (i === -1 || j < 0 || j >= list.length) return;
    [list[i], list[j]] = [list[j], list[i]];
    syncDomOrder(panelKey);
    refreshLayerList();
    pushHistory();
  }
  function bringToFront(panelKey, layerId){
    pushHistory();
    const list = state[panelKey].layers;
    const i = list.findIndex(l => l.id === layerId);
    if (i === -1) return;
    const [layer] = list.splice(i,1);
    list.push(layer);
    syncDomOrder(panelKey);
    refreshLayerList();
    pushHistory();
  }
  function sendToBack(panelKey, layerId){
    pushHistory();
    const list = state[panelKey].layers;
    const i = list.findIndex(l => l.id === layerId);
    if (i === -1) return;
    const [layer] = list.splice(i,1);
    list.unshift(layer);
    syncDomOrder(panelKey);
    refreshLayerList();
    pushHistory();
  }
  function deleteLayer(panelKey, layerId){
    pushHistory();
    const list = state[panelKey].layers;
    const idx = list.findIndex(l => l.id === layerId);
    if (idx === -1) return;

    const layer = list[idx];
    layer.wrap?.remove();
    list.splice(idx,1);

    const sel = selectedLayer(panelKey);
    if (!sel || sel.id === layerId) el.textInput.value = "";

    state[panelKey].selectedId = list.length ? list[list.length-1].id : null;
    if (state[panelKey].selectedId) {
      setSelected(panelKey, state[panelKey].selectedId);
    } else {
      updateEmpty(panelKey);
      refreshLayerList();
      updateUIFromSelection();
    }
    pushHistory();
  }

  function withSelected(fn){
    return (e)=>{
      e.stopPropagation();
      const layer = selectedLayer(editPanel);
      if (!layer) return;
      fn(editPanel, layer.id);
    };
  }

  el.tb_back.addEventListener('click', withSelected(sendToBack));
  el.tb_down.addEventListener('click', withSelected((p,id)=>moveLayer(p,id,-1)));
  el.tb_up.addEventListener('click', withSelected((p,id)=>moveLayer(p,id,+1)));
  el.tb_front.addEventListener('click', withSelected(bringToFront));
  el.tb_rotL.addEventListener('click', withSelected((p,id)=>{
    pushHistory();
    const l=getLayer(p,id);
    l.rotation=normalizeDeg(l.rotation-10);
    renderLayerTransform(l); updateUIFromSelection(); refreshLayerList();
    pushHistory();
  }));
  el.tb_rotR.addEventListener('click', withSelected((p,id)=>{
    pushHistory();
    const l=getLayer(p,id);
    l.rotation=normalizeDeg(l.rotation+10);
    renderLayerTransform(l); updateUIFromSelection(); refreshLayerList();
    pushHistory();
  }));
  el.tb_del.addEventListener('click', withSelected(deleteLayer));

  function screenToLayerLocal(layer, panelKey, clientX, clientY){
    const r = frame(panelKey).getBoundingClientRect();
    const cx = r.left + r.width/2 + layer.x;
    const cy = r.top  + r.height/2 + layer.y;
    const dx = clientX - cx, dy = clientY - cy;
    const rad = (layer.rotation * Math.PI) / 180;
    const cos = Math.cos(-rad), sin = Math.sin(-rad);
    const ux = dx * cos - dy * sin;
    const uy = dx * sin + dy * cos;
    return { x: ux / layer.scale, y: uy / layer.scale };
  }
  function localToScreenDelta(layer, localX, localY, scale){
    const rad = (layer.rotation * Math.PI) / 180;
    const cos = Math.cos(rad), sin = Math.sin(rad);
    const sx = localX * scale, sy = localY * scale;
    return { x: sx * cos - sy * sin, y: sx * sin + sy * cos };
  }

  function attachWheel(panelKey){
    frame(panelKey).addEventListener('wheel', (e)=>{
      if (panelKey !== editPanel) return;
      if (!s(panelKey).layers.length) return;

      const layer = selectedLayer(panelKey) || s(panelKey).layers[s(panelKey).layers.length-1];
      if (!layer) return;

      e.preventDefault();
      setSelected(panelKey, layer.id);

      if (e.shiftKey){
        pushHistory();
        layer.rotation = normalizeDeg(layer.rotation + (e.deltaY > 0 ? 5 : -5));
        el.rotateRange.value = Math.round(layer.rotation);
        el.rotateValue.textContent = Math.round(layer.rotation) + '¬∞';
        renderLayerTransform(layer);
        refreshLayerList();
        pushHistory();
        return;
      }

      pushHistory();

      const zoomFactor = e.deltaY < 0 ? 1.08 : 1/1.08;
      const local = screenToLayerLocal(layer, panelKey, e.clientX, e.clientY);

      const oldScale = layer.scale;
      const newScale = clamp(oldScale * zoomFactor, 0.30, 4.00);

      const oldDelta = localToScreenDelta(layer, local.x, local.y, oldScale);
      const newDelta = localToScreenDelta(layer, local.x, local.y, newScale);

      layer.x += (oldDelta.x - newDelta.x);
      layer.y += (oldDelta.y - newDelta.y);
      layer.scale = newScale;

      el.zoomRange.value = Math.round(layer.scale * 100);
      el.zoomValue.textContent = Math.round(layer.scale * 100) + '%';
      renderLayerTransform(layer);
      refreshLayerList();

      pushHistory();
    }, { passive:false });
  }
  attachWheel(PANEL.FRONT);
  attachWheel(PANEL.REAR);

  el.zoomRange.addEventListener('input', ()=>{
    const layer = selectedLayer(editPanel); if (!layer) return;
    pushHistory();
    layer.scale = parseInt(el.zoomRange.value,10)/100;
    el.zoomValue.textContent = Math.round(layer.scale*100) + '%';
    renderLayerTransform(layer);
    refreshLayerList();
    pushHistory();
  });
  el.rotateRange.addEventListener('input', ()=>{
    const layer = selectedLayer(editPanel); if (!layer) return;
    pushHistory();
    layer.rotation = normalizeDeg(parseInt(el.rotateRange.value,10));
    el.rotateValue.textContent = Math.round(layer.rotation) + '¬∞';
    renderLayerTransform(layer);
    refreshLayerList();
    pushHistory();
  });
  el.resetBtn.addEventListener('click', ()=>{
    const layer = selectedLayer(editPanel); if (!layer) return;
    pushHistory();
    layer.x=0;layer.y=0;layer.scale=1;layer.rotation=0;
    el.zoomRange.value=100;el.rotateRange.value=0;
    el.zoomValue.textContent='100%';el.rotateValue.textContent='0¬∞';
    renderLayerTransform(layer);
    refreshLayerList();
    pushHistory();
  });

  function startMoveDrag(e, panelKey){
    const layer = selectedLayer(panelKey);
    if (!layer) return;
    moving=true;
    startX=e.clientX; startY=e.clientY;
    startLX=layer.x; startLY=layer.y;
    frame(panelKey).style.cursor='grabbing';
    e.preventDefault();
  }

  function attachMouse(panelKey){
    frame(panelKey).addEventListener('mousedown', (e)=>{
      if (currentView === PANEL.MERGE && editPanel !== panelKey){
        editPanel = panelKey;
        el.panelFront.classList.toggle('focus', editPanel === PANEL.FRONT);
        el.panelRear.classList.toggle('focus', editPanel === PANEL.REAR);

        el.frameBgSwatch.style.background = s(editPanel).bgColor;
        el.frameBgValue.textContent = s(editPanel).bgColor;

        updateArchUI(); setTitle(); refreshLayerList(); updateUIFromSelection();
      }

      if (panelKey !== editPanel) return;
      if (!s(panelKey).layers.length) return;

      const wrap = e.target.closest?.('.layer-wrap');
      if (wrap?.dataset?.layerId) setSelected(panelKey, wrap.dataset.layerId);
      else if (!s(panelKey).selectedId) setSelected(panelKey, s(panelKey).layers[s(panelKey).layers.length - 1].id);

      const layer = selectedLayer(panelKey);
      if (!layer) return;

      startMoveDrag(e, panelKey);
    });
  }
  attachMouse(PANEL.FRONT);
  attachMouse(PANEL.REAR);

  document.addEventListener('mousemove', (e)=>{
    if (!moving) return;
    const layer = selectedLayer(editPanel);
    if (!layer) return;
    layer.x = startLX + (e.clientX - startX);
    layer.y = startLY + (e.clientY - startY);
    renderLayerTransform(layer);
  });

  document.addEventListener('mouseup', ()=>{
    if (moving){
      moving = false;
      frame(editPanel).style.cursor = frame(editPanel).classList.contains('has-any') ? 'move' : 'default';
      refreshLayerList();
      pushHistory();
    }
  });

  /* ============================
     Library UI + Upload (shared)
     ============================ */
  function refreshLibrary(){
    el.libraryGrid.innerHTML = '';
    el.libraryCount.textContent = String(imageLibrary.length);

    if (!imageLibrary.length){
      const empty = document.createElement('div');
      empty.style.gridColumn = '1 / -1';
      empty.style.padding = '8px';
      empty.style.color = 'var(--text-color-light)';
      empty.style.fontWeight = '900';
      empty.style.fontSize = '13px';
      empty.textContent = 'No images yet. Upload above.';
      el.libraryGrid.appendChild(empty);
      return;
    }

    imageLibrary.forEach(item=>{
      const card = document.createElement('div');
      card.className = 'lib-item';
      card.draggable = true;
      card.title = 'Drag onto a panel to add';

      const img = document.createElement('img');
      img.src = item.src;
      card.appendChild(img);

      const x = document.createElement('button');
      x.className = 'lib-x';
      x.type = 'button';
      x.textContent = '√ó';
      x.title = 'Remove from library';
      x.addEventListener('click', (e)=>{
        e.stopPropagation();
        pushHistory();
        const idx = imageLibrary.findIndex(a=>a.libId === item.libId);
        if (idx !== -1) imageLibrary.splice(idx,1);
        refreshLibrary();
        pushHistory();
      });
      card.appendChild(x);

      card.addEventListener('dragstart', (e)=>{
        const payload = { kind:'library', libId: item.libId };
        e.dataTransfer.setData(DND.mime, DND.make(payload));
        e.dataTransfer.effectAllowed = 'copy';
      });

      // Optional: click to add to current edit panel
      card.addEventListener('click', ()=>{
        createImageLayerFromLibrary(editPanel, item.libId, null);
      });

      el.libraryGrid.appendChild(card);
    });
  }

  async function addToLibraryFromFile(file){
    const src = await new Promise((resolve, reject)=>{
      const reader = new FileReader();
      reader.onload = (e)=> resolve(e.target.result);
      reader.onerror = reject;
      reader.readAsDataURL(file);
    });

    const libId = libUid();
    const name = file.name || 'Image';

    // measure natural size once (optional but helps)
    const dims = await new Promise((resolve)=>{
      const img = new Image();
      img.onload = ()=> resolve({ w: img.naturalWidth || 1, h: img.naturalHeight || 1 });
      img.onerror = ()=> resolve({ w: 1, h: 1 });
      img.src = src;
    });

    imageLibrary.push({ libId, src, name, naturalW: dims.w, naturalH: dims.h });
  }

  el.uploadZone.addEventListener('click', () => el.fileInput.click());
  el.uploadZone.addEventListener('dragover', (e) => { e.preventDefault(); el.uploadZone.classList.add('dragover'); });
  el.uploadZone.addEventListener('dragleave', () => el.uploadZone.classList.remove('dragover'));
  el.uploadZone.addEventListener('drop', async (e) => {
    e.preventDefault();
    el.uploadZone.classList.remove('dragover');
    const files = Array.from(e.dataTransfer.files || []).filter(f => f.type.startsWith('image/'));
    if (!files.length) return;

    pushHistory();
    for (const f of files) await addToLibraryFromFile(f);
    refreshLibrary();
    pushHistory();
  });

  el.fileInput.addEventListener('change', async (e) => {
    const files = Array.from(e.target.files || []).filter(f => f.type.startsWith('image/'));
    if (!files.length) return;
    pushHistory();
    for (const f of files) await addToLibraryFromFile(f);
    refreshLibrary();
    pushHistory();
    el.fileInput.value = '';
  });

  function findLibraryItem(libId){
    return imageLibrary.find(x=>x.libId === libId) || null;
  }

  /* ============================
     Create layers
     ============================ */
  function createImageLayer(panelKey, src, name="Image", naturalW=1, naturalH=1, initTransform=null){
    const id = uid();

    const wrap = document.createElement('div');
    wrap.className = 'layer-wrap';
    wrap.dataset.layerId = id;
    wrap.dataset.panelKey = panelKey;

    // allow dragging this layer between panels
    wrap.draggable = true;
    wrap.addEventListener('dragstart', (e)=>{
      const layer = getLayer(panelKey, id);
      if (!layer) return;
      const payload = { kind:'layer', fromPanel: panelKey, layerId: id };
      e.dataTransfer.setData(DND.mime, DND.make(payload));
      e.dataTransfer.effectAllowed = 'move';
      // (nice) ensure it is selected when dragging
      setSelected(panelKey, id);
    });

    const img = document.createElement('img');
    img.className = 'layer-img';
    img.src = src;
    img.draggable = false;

    wrap.appendChild(img);
    stack(panelKey).appendChild(wrap);

    const layer = {
      id, type:'image', name,
      x:0, y:0, scale:1, rotation:0,
      src, naturalW:naturalW || 1, naturalH:naturalH || 1,
      wrap, img
    };

    if (initTransform){
      layer.x = initTransform.x ?? 0;
      layer.y = initTransform.y ?? 0;
      layer.scale = initTransform.scale ?? 1;
      layer.rotation = initTransform.rotation ?? 0;
    }

    wrap.addEventListener('mousedown', () => setSelected(panelKey, id));

    img.onload = () => {
      layer.naturalW = img.naturalWidth || layer.naturalW;
      layer.naturalH = img.naturalHeight || layer.naturalH;

      fitImageBaseToFrame(panelKey, layer);

      wrap.style.display = 'block';
      state[panelKey].layers.push(layer);

      renderLayerTransform(layer);
      setSelected(panelKey, id);
      updateEmpty(panelKey);
      refreshLayerList();
      pushHistory();
    };
  }

  function createImageLayerFromLibrary(panelKey, libId, dropEvent){
    const item = findLibraryItem(libId);
    if (!item) return;

    pushHistory();

    // If dropped, place at cursor position relative to frame center
    let init = null;
    if (dropEvent){
      const fr = frame(panelKey).getBoundingClientRect();
      const cx = fr.left + fr.width/2;
      const cy = fr.top  + fr.height/2;
      init = {
        x: (dropEvent.clientX - cx),
        y: (dropEvent.clientY - cy),
        scale: 1,
        rotation: 0
      };
    }

    createImageLayer(panelKey, item.src, item.name, item.naturalW, item.naturalH, init);
  }

  function createTextLayer(panelKey, textValue){
    pushHistory();
    const id = uid();

    const wrap = document.createElement('div');
    wrap.className = 'layer-wrap';
    wrap.dataset.layerId = id;
    wrap.dataset.panelKey = panelKey;

    const box = document.createElement('div');
    box.className = 'layer-textbox';
    wrap.appendChild(box);

    stack(panelKey).appendChild(wrap);

    const layer = {
      id, type:'text', name:'Text',
      x:0, y:0, scale:1, rotation:0,
      wrap, textEl: box,
      text: {
        value: textValue || "",
        fontPx: parseInt(el.textSizeRange.value,10),
        color: normalizeHex(el.textColorValue.textContent) || "#000000",
        bg: normalizeHex(el.bgColorValue.textContent) || "#FFFFFF",
        bgOpacity: parseInt(el.bgOpacityRange.value,10)/100
      }
    };

    wrap.addEventListener('mousedown', () => setSelected(panelKey, id));

    wrap.style.display = 'block';
    state[panelKey].layers.push(layer);

    renderTextLayer(layer);
    renderLayerTransform(layer);

    setSelected(panelKey, id);
    updateEmpty(panelKey);
    refreshLayerList();
    pushHistory();
  }

  /* ============================
     Move layer between panels (drag)
     ============================ */
  function moveLayerToOtherPanel(fromPanel, layerId, toPanel, dropEvent){
    if (fromPanel === toPanel) return;

    const layer = getLayer(fromPanel, layerId);
    if (!layer) return;

    pushHistory();

    // capture transform
    const oldFr = frame(fromPanel).getBoundingClientRect();
    const newFr = frame(toPanel).getBoundingClientRect();

    // Keep relative position within frame
    // layer.x/y is px relative to center of old frame.
    const relX = oldFr.width  ? (layer.x / oldFr.width)  : 0;
    const relY = oldFr.height ? (layer.y / oldFr.height) : 0;

    let newX = relX * newFr.width;
    let newY = relY * newFr.height;

    // If dropped, place at cursor on new panel (more intuitive)
    if (dropEvent){
      const cx = newFr.left + newFr.width/2;
      const cy = newFr.top  + newFr.height/2;
      newX = (dropEvent.clientX - cx);
      newY = (dropEvent.clientY - cy);
    }

    const init = { x: newX, y: newY, scale: layer.scale, rotation: layer.rotation };

    // remove old
    const list = state[fromPanel].layers;
    const idx = list.findIndex(l=>l.id === layerId);
    if (idx !== -1){
      list[idx].wrap?.remove();
      list.splice(idx,1);
    }
    if (state[fromPanel].selectedId === layerId) state[fromPanel].selectedId = null;

    // recreate on target
    if (layer.type === 'image'){
      createImageLayer(toPanel, layer.src, layer.name, layer.naturalW, layer.naturalH, init);
    } else {
      // move text (keep style)
      const id = uid();
      const wrap = document.createElement('div');
      wrap.className = 'layer-wrap';
      wrap.dataset.layerId = id;
      wrap.dataset.panelKey = toPanel;

      const box = document.createElement('div');
      box.className = 'layer-textbox';
      wrap.appendChild(box);

      stack(toPanel).appendChild(wrap);

      const newLayer = {
        id, type:'text', name:'Text',
        x:init.x, y:init.y, scale:init.scale, rotation:init.rotation,
        wrap, textEl: box,
        text: {...layer.text}
      };

      // allow dragging between panels (optional)
      wrap.draggable = true;
      wrap.addEventListener('dragstart', (e)=>{
        const payload = { kind:'layer', fromPanel: toPanel, layerId: id };
        e.dataTransfer.setData(DND.mime, DND.make(payload));
        e.dataTransfer.effectAllowed = 'move';
        setSelected(toPanel, id);
      });

      wrap.addEventListener('mousedown', () => setSelected(toPanel, id));
      wrap.style.display = 'block';
      state[toPanel].layers.push(newLayer);

      renderTextLayer(newLayer);
      renderLayerTransform(newLayer);

      setSelected(toPanel, id);
      updateEmpty(toPanel);
      refreshLayerList();
      pushHistory();
    }

    updateEmpty(fromPanel);
    refreshLayerList();
    pushHistory();
  }

  /* ============================
     Panel drop targets
     ============================ */
  function setDropHighlight(panelKey, on){
    frame(panelKey).classList.toggle('drop-target', !!on);
  }

  function attachPanelDnd(panelKey){
    const fr = frame(panelKey);

    fr.addEventListener('dragenter', (e)=>{
      const data = e.dataTransfer.getData(DND.mime);
      if (!data) return;
      e.preventDefault();
      setDropHighlight(panelKey, true);
    });
    fr.addEventListener('dragover', (e)=>{
      const data = e.dataTransfer.getData(DND.mime);
      if (!data) return;
      e.preventDefault();
      e.dataTransfer.dropEffect = 'copy';
    });
    fr.addEventListener('dragleave', (e)=>{
      // when leaving to a child, ignore
      const rect = fr.getBoundingClientRect();
      if (e.clientX >= rect.left && e.clientX <= rect.right && e.clientY >= rect.top && e.clientY <= rect.bottom) return;
      setDropHighlight(panelKey, false);
    });
    fr.addEventListener('drop', (e)=>{
      const raw = e.dataTransfer.getData(DND.mime);
      const payload = DND.parse(raw);
      setDropHighlight(panelKey, false);
      if (!payload) return;

      e.preventDefault();

      // If in merge view, dropping also sets editPanel to that panel for consistency
      if (currentView === PANEL.MERGE){
        editPanel = panelKey;
        el.panelFront.classList.toggle('focus', editPanel === PANEL.FRONT);
        el.panelRear.classList.toggle('focus', editPanel === PANEL.REAR);
      }

      if (payload.kind === 'library'){
        createImageLayerFromLibrary(panelKey, payload.libId, e);
        return;
      }
      if (payload.kind === 'layer'){
        const fromPanel = payload.fromPanel;
        const layerId = payload.layerId;
        if (!fromPanel || !layerId) return;
        moveLayerToOtherPanel(fromPanel, layerId, panelKey, e);
        return;
      }
    });
  }

  attachPanelDnd(PANEL.FRONT);
  attachPanelDnd(PANEL.REAR);

  /* ============================
     Text UI
     ============================ */
  el.textSizeRange.addEventListener('input', ()=>{ el.textSizeValue.textContent=el.textSizeRange.value+'px'; });
  el.bgOpacityRange.addEventListener('input', ()=>{ el.bgOpacityValue.textContent=el.bgOpacityRange.value+'%'; });

  el.addTextBtn.addEventListener('click', ()=>{
    const value = el.textInput.value.trim();
    if (!value){ alert("Type some text first."); return; }
    createTextLayer(editPanel, value);
  });

  el.updateTextBtn.addEventListener('click', ()=>{
    const layer = selectedLayer(editPanel);
    if (!layer || layer.type !== 'text'){
      alert("Select a text layer first (click it in canvas or layers list).");
      return;
    }
    pushHistory();
    layer.text.value = el.textInput.value;
    layer.text.fontPx = parseInt(el.textSizeRange.value,10);
    layer.text.color = normalizeHex(el.textColorValue.textContent) || "#000000";
    layer.text.bg = normalizeHex(el.bgColorValue.textContent) || "#FFFFFF";
    layer.text.bgOpacity = parseInt(el.bgOpacityRange.value,10)/100;
    renderTextLayer(layer);
    renderLayerTransform(layer);
    refreshLayerList();
    pushHistory();
  });

  el.deleteTextLayerBtn.addEventListener('click', ()=>{
    const layer = selectedLayer(editPanel);
    if (!layer || layer.type !== 'text'){ alert("Select a text layer first."); return; }
    deleteLayer(editPanel, layer.id);
    el.textInput.value = "";
  });

  function applyMagnetSize(w, h){
    magnetW = w; magnetH = h;
    fitFrames();
    refitAll();
    el.sizeInfo.textContent =
      `Layout locked. Ratio: ${(w/h).toFixed(4)}:1 ‚Ä¢ Export: ${h}" H √ó ${w}" W (print 100%)`;
    setTitle();
  }

  function handleApplyClick(){
    const h = sanitizeInches(el.hIn.value);
    const w = sanitizeInches(el.wIn.value);
    if (w === null || h === null || w <= 0 || h <= 0){
      alert("Enter valid inches.");
      return;
    }
    el.wIn.value = w;
    el.hIn.value = h;

    el.applySizeBtn.disabled = true;
    el.applySizeBtn.textContent = "Applying‚Ä¶";
    requestAnimationFrame(()=>{
      pushHistory();
      applyMagnetSize(w,h);
      setTimeout(()=>{
        el.applySizeBtn.disabled = false;
        el.applySizeBtn.textContent = "‚úÖ Apply";
        pushHistory();
      }, 120);
    });
  }
  el.applySizeBtn.addEventListener('click', handleApplyClick);
  [el.wIn, el.hIn].forEach(inp => inp.addEventListener('keydown', (e)=>{ if(e.key==='Enter') handleApplyClick(); }));

  el.presetSelect.addEventListener('change', () => {
    const v = el.presetSelect.value;
    if (!v) return;
    const parts = v.split('x').map(Number);
    const hh = parts[0], ww = parts[1];
    el.hIn.value = hh; el.wIn.value = ww;
    handleApplyClick();
    el.presetSelect.value = "";
  });

  function applyViewUI(){
    if (currentView === PANEL.MERGE){
      el.panelFront.style.display = 'block';
      el.panelRear.style.display = 'block';
      el.mergeDownloadGroup.style.display = 'grid';
      el.downloadBtn.style.display = 'flex';
    } else if (currentView === PANEL.FRONT){
      editPanel = PANEL.FRONT;
      el.panelFront.style.display = 'block';
      el.panelRear.style.display = 'none';
      el.mergeDownloadGroup.style.display = 'none';
      el.downloadBtn.style.display = 'flex';
    } else {
      editPanel = PANEL.REAR;
      el.panelFront.style.display = 'none';
      el.panelRear.style.display = 'block';
      el.mergeDownloadGroup.style.display = 'none';
      el.downloadBtn.style.display = 'flex';
    }

    el.panelFront.classList.toggle('focus', editPanel === PANEL.FRONT);
    el.panelRear.classList.toggle('focus', editPanel === PANEL.REAR);

    applyFrameBg(PANEL.FRONT);
    applyFrameBg(PANEL.REAR);

    el.frameBgSwatch.style.background = s(editPanel).bgColor;
    el.frameBgValue.textContent = s(editPanel).bgColor;

    const label = currentView === PANEL.FRONT ? "Download Front JPG"
                 : currentView === PANEL.REAR  ? "Download Rear JPG"
                 : "Download JPG";
    el.downloadLabel.textContent = label;

    updateArchUI();
    setTitle();
  }

  document.querySelectorAll('.panel-btn[data-panel]').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      pushHistory();
      document.querySelectorAll('.panel-btn[data-panel]').forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');

      currentView = btn.dataset.panel;

      applyViewUI();
      fitFrames();
      refitAll();
      pushHistory();
    });
  });

  el.panelFront.addEventListener('click', ()=>{
    if (currentView !== PANEL.MERGE) return;
    if (editPanel !== PANEL.FRONT) {
      editPanel = PANEL.FRONT;
      applyViewUI();
      refreshLayerList();
      updateUIFromSelection();
      pushHistory();
    }
  });
  el.panelRear.addEventListener('click', ()=>{
    if (currentView !== PANEL.MERGE) return;
    if (editPanel !== PANEL.REAR) {
      editPanel = PANEL.REAR;
      applyViewUI();
      refreshLayerList();
      updateUIFromSelection();
      pushHistory();
    }
  });

  /* ============================
     Export
     ============================ */
  async function downloadSinglePanel(panelKey){
    const MAX_W_PX = 6000;
    const dpi = Math.max(72, Math.floor(MAX_W_PX / magnetW));
    const outW = Math.round(magnetW * dpi);
    const outH = Math.round(magnetH * dpi);

    const canvas = document.createElement('canvas');
    canvas.width = outW;
    canvas.height = outH;
    const ctx = canvas.getContext('2d');

    if (isArchPanel(panelKey)){
      ctx.save();
      ctx.beginPath();
      buildArchPathOnCtx(ctx, panelKey, outW, outH);
      ctx.closePath();
      ctx.clip();
      await renderPanelToCtx(ctx, panelKey, 0, 0, outW, outH);
      ctx.restore();
    } else {
      await renderPanelToCtx(ctx, panelKey, 0, 0, outW, outH);
    }

    return new Promise((resolve, reject) => {
      canvas.toBlob((blob)=>{
        if (!blob) return reject(new Error("Blob failed"));
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `vinyl-${panelKey}-${frameType}-${magnetH}x${magnetW}in-${dpi}dpi-${Date.now()}.jpg`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
        resolve();
      }, 'image/jpeg', 0.92);
    });
  }

  function buildArchPathOnCtx(ctx, panelKey, W, H){
    const xf = archXform[panelKey];
    const deg = normalize360(xf.rot);
    const rad = deg * Math.PI / 180;
    const sx = xf.flipX ? -1 : 1;
    const sy = xf.flipY ? -1 : 1;

    ctx.save();
    ctx.translate(W/2, H/2);
    ctx.rotate(rad);
    ctx.scale(sx, sy);
    ctx.translate(-W/2, -H/2);

    const s = 0.5;

    if (panelKey === PANEL.FRONT){
      ctx.moveTo(0, H);
      ctx.lineTo(W, H);
      ctx.lineTo(W, 0);
      ctx.lineTo(s*W, 0);
      ctx.lineTo(0, H);
    } else {
      ctx.moveTo(0, H);
      ctx.lineTo(W, H);
      ctx.lineTo(s*W, 0);
      ctx.lineTo(0, 0);
      ctx.lineTo(0, H);
    }

    ctx.restore();
  }

  async function handleSingleDownload(){
    try{ await downloadSinglePanel(editPanel); }
    catch(err){ console.warn(err); alert("Export failed. Try smaller size or fewer layers."); }
  }
  el.downloadBtn.addEventListener('click', handleSingleDownload);

  async function handleFrontDownload(){
    try{ await downloadSinglePanel(PANEL.FRONT); }
    catch(err){ console.warn(err); alert("Front export failed."); }
  }
  async function handleRearDownload(){
    try{ await downloadSinglePanel(PANEL.REAR); }
    catch(err){ console.warn(err); alert("Rear export failed."); }
  }
  el.downloadFrontBtn.addEventListener('click', handleFrontDownload);
  el.downloadRearBtn.addEventListener('click', handleRearDownload);

  async function handleBothDownload(){
    try{
      el.downloadBothBtn.disabled = true;
      el.downloadBothBtn.textContent = "Preparing‚Ä¶";
      await downloadSinglePanel(PANEL.FRONT);
      await new Promise(r=>setTimeout(r, 250));
      await downloadSinglePanel(PANEL.REAR);
    } catch(err){
      console.warn(err);
      alert("Export failed. Try smaller size or fewer layers.");
    } finally{
      el.downloadBothBtn.disabled = false;
      el.downloadBothBtn.textContent = "‚¨á‚¨á Download Both (Front + Rear)";
    }
  }
  el.downloadBothBtn.addEventListener('click', handleBothDownload);

  async function renderPanelToCtx(ctx, panelKey, offX, offY, outW, outH){
    ctx.save();
    ctx.translate(offX, offY);

    ctx.fillStyle = s(panelKey).bgColor || '#FFFFFF';
    ctx.fillRect(0,0,outW,outH);

    const fr = frame(panelKey).getBoundingClientRect();
    const pxPerScreenX = outW / fr.width;
    const pxPerScreenY = outH / fr.height;

    for (const layer of s(panelKey).layers){
      ctx.save();
      ctx.translate(outW/2, outH/2);
      ctx.translate(layer.x * pxPerScreenX, layer.y * pxPerScreenY);
      ctx.rotate((layer.rotation * Math.PI)/180);
      ctx.scale(layer.scale, layer.scale);

      if (layer.type === 'image'){
        const img = await loadImage(layer.src);
        const drawW = (layer.img?.width || img.naturalWidth) * pxPerScreenX;
        const drawH = (layer.img?.height || img.naturalHeight) * pxPerScreenY;
        ctx.drawImage(img, -drawW/2, -drawH/2, drawW, drawH);
      } else {
        const t = layer.text;
        const fontPx = (t.fontPx || 32) * pxPerScreenX;

        ctx.font = `900 ${Math.max(1, Math.round(fontPx))}px 'Poppins', -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        const lines = (t.value || '').split('\n');
        const lineHeight = Math.max(1, fontPx) * 1.2;
        const padding = 20 * pxPerScreenX;

        let maxW = 0;
        lines.forEach(line => { maxW = Math.max(maxW, ctx.measureText(line).width); });
        const bgW = maxW + padding * 2;
        const bgH = lines.length * lineHeight + padding * 2;

        const rgb = hexToRgb(t.bg || '#FFFFFF');
        ctx.fillStyle = `rgba(${rgb.r},${rgb.g},${rgb.b},${t.bgOpacity ?? 0.9})`;
        roundRect(ctx, -bgW/2, -bgH/2, bgW, bgH, 16 * pxPerScreenX);
        ctx.fill();

        ctx.fillStyle = t.color || '#000000';
        lines.forEach((line, i) => {
          const y = -((lines.length - 1) * lineHeight)/2 + i*lineHeight;
          ctx.fillText(line, 0, y);
        });
      }

      ctx.restore();
    }

    ctx.restore();
  }

  function roundRect(ctx, x, y, w, h, r){
    const radius = Math.max(0, Math.min(r, Math.min(w,h)/2));
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + w - radius, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
    ctx.lineTo(x + w, y + h - radius);
    ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
    ctx.lineTo(x + radius, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
  }

  function loadImage(src){
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = async () => { try{ if (img.decode) await img.decode(); } catch{} resolve(img); };
      img.onerror = reject;
      img.src = src;
    });
  }

  let activePicker = null;
  function openPicker(anchorEl, initialHex, onHex){
    if (activePicker) activePicker.close();
    activePicker = new HexOnlyPicker({ anchorEl, initialHex, onChange: (hex)=> onHex(hex) });
    activePicker.open();
  }

  function setFrameBg(hex){
    const v = normalizeHex(hex) || "#FFFFFF";
    pushHistory();
    s(editPanel).bgColor = v;
    el.frameBgSwatch.style.background = v;
    el.frameBgValue.textContent = v;
    applyFrameBg(editPanel);
    pushHistory();
  }
  el.frameBgRow.addEventListener('click', ()=> openPicker(el.frameBgRow, s(editPanel).bgColor, setFrameBg));
  el.frameBgSwatch.addEventListener('click', (e)=>{ e.stopPropagation(); openPicker(el.frameBgRow, s(editPanel).bgColor, setFrameBg); });

  function setTextColor(hex){
    const v = normalizeHex(hex) || "#000000";
    el.textColorSwatch.style.background = v;
    el.textColorValue.textContent = v;

    const layer = selectedLayer(editPanel);
    if (layer && layer.type === 'text'){
      pushHistory();
      layer.text.color = v;
      renderTextLayer(layer);
      pushHistory();
    }
  }
  el.textColorRow.addEventListener('click', ()=> openPicker(el.textColorRow, el.textColorValue.textContent, setTextColor));
  el.textColorSwatch.addEventListener('click', (e)=>{ e.stopPropagation(); openPicker(el.textColorRow, el.textColorValue.textContent, setTextColor); });

  function setBgColor(hex){
    const v = normalizeHex(hex) || "#FFFFFF";
    el.bgColorSwatch.style.background = v;
    el.bgColorValue.textContent = v;

    const layer = selectedLayer(editPanel);
    if (layer && layer.type === 'text'){
      pushHistory();
      layer.text.bg = v;
      renderTextLayer(layer);
      pushHistory();
    }
  }
  el.bgColorRow.addEventListener('click', ()=> openPicker(el.bgColorRow, el.bgColorValue.textContent, setBgColor));
  el.bgColorSwatch.addEventListener('click', (e)=>{ e.stopPropagation(); openPicker(el.bgColorRow, el.bgColorValue.textContent, setBgColor); });

  el.frameTypeSelect.addEventListener('change', ()=>{
    const v = el.frameTypeSelect.value;
    frameType =
      v === 'arch'  ? FRAME_TYPE.ARCH :
      v === 'mixed' ? FRAME_TYPE.MIXED :
      FRAME_TYPE.REGULAR;
    pushHistory();
    applyFrameType();
  });

  function applySnapshot(snapshot){
    applyingHistory = true;
    try{
      const data = JSON.parse(snapshot);
      magnetW = data.magnetW; magnetH = data.magnetH;
      currentView = data.currentView; editPanel = data.editPanel;
      frameType = data.frameType || FRAME_TYPE.REGULAR;

      // NEW: restore per-panel arch transforms (fallback if older history)
      if (data.archXform && data.archXform.front && data.archXform.rear){
        archXform[PANEL.FRONT] = {
          rot: data.archXform.front.rot || 0,
          flipX: !!data.archXform.front.flipX,
          flipY: !!data.archXform.front.flipY
        };
        archXform[PANEL.REAR] = {
          rot: data.archXform.rear.rot || 0,
          flipX: !!data.archXform.rear.flipX,
          flipY: !!data.archXform.rear.flipY
        };
      } else {
        // default
        archXform[PANEL.FRONT] = archXform[PANEL.FRONT] || { rot:0, flipX:false, flipY:false };
        archXform[PANEL.REAR]  = archXform[PANEL.REAR]  || { rot:0, flipX:false, flipY:false };
      }

      el.frameTypeSelect.value = frameType;

      [PANEL.FRONT, PANEL.REAR].forEach(pk=>{
        stack(pk).innerHTML = '';
        state[pk].layers.length = 0;
        state[pk].selectedId = data.state[pk].selectedId;
        state[pk].bgColor = (normalizeHex(data.state[pk].bgColor) || "#FFFFFF");
      });

      const rebuild = async (pk)=>{
        for (const L of data.state[pk].layers){
          if (L.type === 'image'){
            await new Promise((res)=>{
              const wrap = document.createElement('div');
              wrap.className = 'layer-wrap';
              wrap.dataset.layerId = L.id;

              const img = document.createElement('img');
              img.className = 'layer-img';
              img.src = L.src;
              img.draggable = false;

              wrap.appendChild(img);
              stack(pk).appendChild(wrap);

              const layer = {
                id:L.id, type:'image', name:L.name,
                x:L.x, y:L.y, scale:L.scale, rotation:L.rotation,
                src:L.src, naturalW:L.naturalW||1, naturalH:L.naturalH||1,
                wrap, img
              };

              wrap.addEventListener('mousedown', () => setSelected(pk, layer.id));

              img.onload = ()=>{
                layer.naturalW = img.naturalWidth || layer.naturalW;
                layer.naturalH = img.naturalHeight || layer.naturalH;
                fitImageBaseToFrame(pk, layer);
                wrap.style.display = 'block';
                state[pk].layers.push(layer);
                renderLayerTransform(layer);
                res();
              };
            });
          } else {
            const wrap = document.createElement('div');
            wrap.className = 'layer-wrap';
            wrap.dataset.layerId = L.id;

            const box = document.createElement('div');
            box.className = 'layer-textbox';
            wrap.appendChild(box);

            stack(pk).appendChild(wrap);

            const layer = {
              id:L.id, type:'text', name:L.name,
              x:L.x, y:L.y, scale:L.scale, rotation:L.rotation,
              wrap, textEl: box,
              text: {...L.text}
            };

            wrap.addEventListener('mousedown', () => setSelected(pk, layer.id));

            wrap.style.display = 'block';
            state[pk].layers.push(layer);
            renderTextLayer(layer);
            renderLayerTransform(layer);
          }
        }
      };

      applyFrameType();
      applyArchTransform(PANEL.FRONT);
      applyArchTransform(PANEL.REAR);
      fitFrames(true);

      Promise.resolve()
        .then(()=>rebuild(PANEL.FRONT))
        .then(()=>rebuild(PANEL.REAR))
        .then(()=>{
          applyViewUI();
          fitFrames(true);
          refitAll();

          if (state[editPanel].selectedId) setSelected(editPanel, state[editPanel].selectedId);
          else refreshLayerList();
        });

    } finally{
      applyingHistory = false;
    }
  }

  el.undoBtn.addEventListener('click', ()=>{
    if (history.length <= 1) return;
    const cur = history.pop();
    redoStack.push(cur);
    applySnapshot(history[history.length-1]);
    updateUndoRedoButtons();
  });
  el.redoBtn.addEventListener('click', ()=>{
    if (!redoStack.length) return;
    const snap = redoStack.pop();
    history.push(snap);
    applySnapshot(snap);
    updateUndoRedoButtons();
  });

  function init(){
    el.textSizeValue.textContent = el.textSizeRange.value + 'px';
    el.bgOpacityValue.textContent = el.bgOpacityRange.value + '%';

    el.hIn.value = magnetH;
    el.wIn.value = magnetW;

    el.frameBgSwatch.style.background = s(editPanel).bgColor;
    el.frameBgValue.textContent = s(editPanel).bgColor;

    el.textColorSwatch.style.background = "#000000";
    el.textColorValue.textContent = "#000000";
    el.bgColorSwatch.style.background = "#FFFFFF";
    el.bgColorValue.textContent = "#FFFFFF";

    fillPresets();
    applyFrameBg(PANEL.FRONT);
    applyFrameBg(PANEL.REAR);

    applyViewUI();
    fitFrames(true);

    applyArchTransform(PANEL.FRONT);
    applyArchTransform(PANEL.REAR);
    updateArchUI();

    updateEmpty(PANEL.FRONT);
    updateEmpty(PANEL.REAR);
    refreshLayerList();
    updateUIFromSelection();

    pushHistory();

    window.addEventListener('resize', ()=>{
      fitFrames();
      refitAll();
      pushHistory();
    });
  }

  init();
</script>
</body>
</html>

